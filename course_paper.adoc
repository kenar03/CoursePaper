:description: Курсовой проект
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:imagesdir: images
:important-caption: ВАЖНО!
:note-caption: ПРИМЕЧАНИЕ
:stem:

= Курсовой проект
:sectnums: |,all|

== Требования к ПО

* Для разработки должна использоваться отладочная плата https://www.waveshare.com/product/arduino-2/boards-kits/nucleo/xnucleo-f411re.htm[XNUCLEO-F411RE]
* Софт должен измерять напряжения с переменного резистора, уставленного на плате расширения
** Для измерения напряжения должен использоваться встроенный АЦП
** [[period]] Период измерения должен быть 50 ms
** [[DMA]] Для получения кода измерения должен использоваться механизм DMA
** Для изменения напряжения должна использоваться плата https://www.waveshare.com/product/arduino-2/shields/others/accessory-shield.htm[Accessories Shield] или https://www.waveshare.com/product/arduino-2/shields/others/analog-test-shield.htm[Analog Test Shield]
** Точность измерения напряжения должна быть не менее 0,01 вольта
** [[filter]] К измеренному напряжению должен быть применен цифровой фильтр вида: +
stem:[tau = int  ((1-e^(-dt/(R*C)), RC > 0 sec), (1, RC<= 0 sec))] +
{nbsp} +
stem:["FilteredValue" = "OldFiltered" + ("Value" - "OldValue") * tau], +
{nbsp} +
где dt -  100 мс; +
Value – текущее нефильтрованное измеренное значение напряжения; +
oldValue -  предыдущее фильтрованное значение.

* Индикация значения измеренного напряжения должна осуществляться через включение/выключение светодиодов
** При максимальном напряжении софт должен зажигать 4 светодиода, при минимальном все светодиоды должны погаснуть.
** Промежуточные значения напряжения должны индицироваться следующим образом.
*** При 0-25% от максимального напряжения зажигается только 1 светодиод
*** При 25-50% от максимального напряжения зажигается только 2 светодиода
*** При 50-75% от максимального напряжения зажигается только 3 светодиода
*** При 75-100% от максимального напряжения зажигается все 4 светодиода

* [[UART]] Передача значений по беспроводному интерфейсу должна осуществляться через модуль https://elecfreaks.com/estore/download/EF03073-Bluetooth_Bee_(HC-05_and_HC-06)User_Guide.pdf[BlueTooth Bee HC-06]
 или https://www.waveshare.com/product/arduino-2/shields/others/io-expansion-shield.htm[I/O Expansion Shield]
** Общение с платой расширения должно осуществляться через USART2
** [[output_format]] формат вывод: +
   "Напряжение: " X.XXX [Units]
* Архитектура должна быть представлена в виде UML диаграмм в пакете Plant UML
* Приложение должно быть написано на языке С++ с использование компилятора ARM 8.40.2
* [[RTOS]] При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и https://github.com/lamer0k/RtosWrapper[С++ обертка над ней]

== Анализ требований к ПО

=== Отладочная плата XNUCLEO-F411RE и плата расширения Accessory Shield

Отладочная плаата XNUCLEO-F411RE - это улучшенная версия отладочной платы STM32 Nucleo, созданная компанией Waveshare. Основана XNUCLEO-F411RE на микроконтроллере STM32F411RET6 с ядром ARM Cortex-4 и предназначена для создания проектов и прототипирования. 

.Отладочная плата XNUCLEO-F411RE
image::XNUCLEO-F411RE.jpg[]

Основные особенности платы XNUCLEO-F411RE:

* совместимость с Arduino;
* подключение по USB;
* наличие светодиодов и пользовательской кнопки.

В ходе выполнения курсового проекта используется плата расширения Accessory Shield.

.Плата расширения Accessory Shield
image::accessory_shield.jpg[]

Accessory Shield - это плата расширения совместимая с популярными платформами для разработки электронных приложений, такими как Arduino UNO, Arduino Leonardo, NUCLEO, XNUCLEO и совместимыми. На плате установлены самые популярные дочерние модули, подходящие для реализации большинства задач.

Особенности платы расширения:

* разъем для подключения плат Arduino;
* разъем XBee для подключения беспроводных модулей;
* OLED дисплей 0,96 дюймов с разрешением 128x64 пикселей;
* RGB-светодиод;
* зуммер;
* потенциометр 10 кОм;
* 3-осевой цифровой акселерометр ADXL345;
* температурный датчик LM75BDP,
* джойстик 5-ти позиционный,
* индикатор состояния XBee,
* индикатор питания,
* кнопка сброса модулей XBee и Arduino,
* часы реального времени (RTC),
* держатель батареи CR1220 для RTC,
* драйвер RGB светодиода,
* джампер выбора режима Отладка/Связь.

=== Софт должен измерять напряжения с переменного резистора, уставленного на плате расширения

Переменный резистор, установленный на плате расширения, согласно спецификации Waveshare, подключен к аналоговому входу микроконтроллера, пин *PA0*.

.Распиновка XNUCLEO-F411RE
image::xnucleo_spec.jpg[]

В плате расширения используется линейный потенциометр с тремя выводами:

* один крайний вывод подключен в питанию 3,3 В (стандартное напряжение питания);
* другой крайний вывод подключен к земле;
* центральный вывод выведен на аналоговый вход микроконтроллера (пин PA0).

Таким образом, при вращении ручки потенциометра напряжение на центральном выводе изменяется от 0 В до 3,3 В.

Поскольку напряжение - аналоговый сигнал, его нужно измерять с помощью аналого-цифрового преобразователя (АЦП).

=== Для измерения напряжения должен использоваться встроенный АЦП с использованием DMA

Микроконтроллер STM32F411RET6 оснащен 12-битным АЦП, поддерживающим 19 каналов и позволяющим имзерять сигналы из 16 внешних источников, 2 внутренних источников, а также канал VBAT (измерение напряжения на линии питания резервной батареи).

Аналого-цифровое преобразование каналов может осуществляться в следующих режимах:

* Single Mode (однократное преобразование) - для выбранного канала преобразование выполняется один раз и останавливается после завершения.
* Continuous Mode (непрерывное преобразование) - автоматическое повторение преобразования выбранного канала без необходимости повторного запуска.
* Scan Mode (режим сканирования) - АЦП выполняет преобразование для группы каналов, заданных в последовательности, по одному за раз. Этот режим не является самостоятельным, а комбинируется с Single или Continuous.
* Discontinuous Mode (Прерывистый режим) - улучшенный режим  сканирования. Разбивает последовательность каналов на подгруппы. АЦП выполняет преобразование заданного числа каналов за один цикл, затем останавливается до следующего триггера.

Поскольку, <<DMA, согласно требованиям к ПО>>, требуется использовать механизм DMA совместно с АЦП, следует использовать режим непрерывного преобразования. АЦП будет передавать считанные значения с помощью DMA автоматически по выбранному адресу, без использования ядра процессора.

 Для того, чтобы настроить АЦП в режиме непрерывного преобразования, нужно:
 . подать тактирование на порт, который будет использоваться для считывания данных с АЦП;
 . настроить порт, подключенный к нужному каналу АЦП, на аналоговый вход;
 . подать тактирование на АЦП;
 . настроить разрешение АЦП;
 . настроить режим преобразования (регистр ADC_CR2);
 . выбрать нужный канал для измерения;
 . настроить канал АЦП на необходимую частоту преобразования;
 . включить АЦП;
 . начать преобразование;
 . дождаться флага готовности преобразования;
 . считать преобразованное значение.

В <<table_ADC, данной таблице>> показаны настройки регистров, необходимых для включения АЦП в режиме непрерывного преобразования.

<<DMA, Согласно требованиям к ПО>>, для получения кода измерения должен использоваться механизм DMA. DMA - это режим обмена данными между периферией и основной памятью, в котором центральный процессор не участвует. Для работы с DMA в микроконтроллер встроены специальные контроллеры DMA.

На микроконтроллере STM32F411RET6 имеется 2 контроллера DMA, каждый из которых имеет 8 каналов, каждый канал имеет 8 потоков, которые подключаются к конкретному периферийному устройству. Если установлен бит DMA регистра ADC_CR2, то по окончании преобразования АЦП генерирует запрос DMA. Контроллер DMA получит этот запрос по внутренней линии связи между периферией и DMA. Затем контроллер DMA считывает данные с АЦП (записанные в регистр ADC_DR) и записывает их в указанный адрес памяти.

В спецификации к микроконтроллеру имеется таблица запросов DMA.

.Таблица запросов DMA
image::DMA_Requests_Tables.png[]

Согласно этой таблице, для того, чтобы генерировать запросы от АЦП, следует использовать контроллер DMA2, канал 0, потоки 0 или 4. В данной работе используется поток 0.

В <<table_DMA, данной таблице>> показана конфигурация регистров DMA для данного проекта.

Алгоритм настройки потока DMA представлен в пункте 9.3.17 в https://www.st.com/resource/en/reference_manual/rm0383-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf[Reference Manual] к STM32F411RET6.

=== Периодичность измерений 50 мс с использованием операционной системы реального времени FreeRTOS

Поскольку, <<period, согласно требованиям к ПО>>, измерения необходимо производить с заданной периодичностью (50 мс), целесообразно использовать операционную систему реального времени.

Операционная система реального времени (ОСРВ) — это ОС, которая предназначена для обработки данных и выполнения задач в строго заданные временные рамки. Она гарантирует, что критически важные процессы завершатся вовремя, минимизируя задержки.

<<RTOS, Согласно требованиям к ПО>>, должна использоваться операционная система реального времени FreeRTOS и обертка над ней. *FreeRTOS* — это компактная операционная система реального времени (ОСРВ) с открытым исходным кодом, предназначенная для встраиваемых систем и микроконтроллеров. Она предоставляет базовые функции для управления задачами, планирования, синхронизации (семафоры, мьютексы, очереди) и работы с ограниченными ресурсами. Под *оберткой* понимается программный слой или библиотека, которая упрощает взаимодействие с FreeRTOS, скрывая её низкоуровневые детали и упрощая разработку.

Так как АЦП и DMA после настройки работают независимо от ядра микроконтроллера, создавать задачу для организации передачи данных между ними не нужно.

В данной таблице представлены задачи, которые выполняются операционной системой реального времени.

.Задачи, выполняемые операционной системой реального времени
|===
| Задача | Описание | Периодичность | Приоритет | Взаимодействие
| [[task1]] Расчет считанного значения напряжения, переданного по DMA | Читает данные DMA, переводит счеты АЦП в напряжение, выполняет фильтрацию, управляет светодиодами, отправляет в очередь. | 50 мс | Высокий | Подготавливает данные для передачи по UART
| Передача данных по UART | Считывает значения, полученные из первой задачи и отправляет их по UART в заданном формате | 500 мс | Низкий | Считывает подготовленные первой задачей данные и передает их по UART
|===

=== Обеспечение точности не менее 0,01 В

Для того, чтобы обеспечить измерение напряжения с требуемой точностью, необходимо обеспечить корректную работу АЦП в непрерывном режиме с передачей данных через DMA.

Точность измерения напряжения определяется следующими факторами:

. Разрешение АЦП: Количество бит влияет на шаг квантования (stem:[\DeltaV])
. Опорное напряжение: Задает диапазон измерений
. Частота АЦП: Влияет на длительность выборки  преобразлования

==== Выбор параметров тактирования

Поскольку в требованиях к ПО не сказано, каким должно быть потребление ресурсов, было решено использовать внешний кварцевый генератор с частотой тактирования 8 МГц. Его будет достаточно для выполнения всех задач.

==== Выбор разрешения АЦП

В STM32F411RET6 АЦП поддерживает разрешения 6, 8, 10 и 12 бит. Формула расчета шага квантования:

[%center]
[stem]
++++
\DeltaV = (V_(ref))/(2^n),
++++

где stem:[V_(ref) = 3,3 В] - опорное напряжение;
   stem:[n] - разрядность АЦП.

Рассмотрим варианты квантования при различных разрешениях.

При stem:[n] = 8 бит:

[%center]
[stem]
++++
\DeltaV = (3,3))/(2^(8)) = 3,3 / 256 = 12,891 мВ
++++

При stem:[n] = 10 бит:

[%center]
[stem]
++++
\DeltaV = (3,3))/(2^(10)) = 3,3 / 1024 = 3,223 мВ
++++

При stem:[n] = 12 бит:

[%center]
[stem]
++++
\DeltaV = (3,3))/(2^(12)) = 3,3 / 4096 = 0,806 мВ
++++

Как можно заметить, 8 бит разрешения не достаточно для обеспечения требуемой точности. 10 бит хватает, но для обеспечения большей устойчивости к шумам следует выбрать разрешение *12 бит*, т.е. установить в регистре ADC_CR1 в поле RES биты 00.

==== Выбор времени преобразования АЦП

Время преобразования необходимо выбрать таким, чтобы оно было меньше заданного периода измерения, т.е. 50 мс.

Чем больше время преобразования, тем точнее преобразованное значение. Руководствуясь этим суждением, следует выбрать время преобразования, максимально близкое к 50 мс.

АЦП тактируется от шины APB2, частота которой в контексте данной задачи равна 8 МГц. В регистре ADC_CCR в поле ADCPRE настраивается значение предделителся частоты. Его минимальное значение составляет 2 (биты 00). Тогда, АЦП тактируется от частоты stem:[(8 МГц)/(2) = 4 МГц].

Время одного такта АЦП равно:

[%center]
[stem]
++++
T_cycle = 1 / (4 * 10^6) = 0,25 мкс.
++++

Время выборки АЦП определяется по формуле:

[%center]
[stem]
++++
T_sample = N_sample * T_cycle,
++++

где stem:[N_sample] - количество циклов выборки (настраивается в регистре ADC_SMPR2, поле SMP0).

Время преобразования АЦП определяется по формуле:

[%center]
[stem]
++++
T_conversion = (N_sample + N_resolution) * T_cycle,
++++
где stem:[N_sample] - количество циклов выборки (настраивается в регистре ADC_SMPR2, поле SMP0); stem:[N_resolution] - разрешение АЦП (было выбрано 12 бит).

Ниже рассчитаны различные значения времени преобразования в зависимости от количества циклов выборки.

.Расчет времени преобразования
|===
| stem:[N_sample] | stem:[T_conversion], мкс
| 3 | 3,75
| 15 | 6,75
| 28 | 10
| 56 | 17
| 84 | 24
| 112 | 31
| 144 | 39
| 480 | 123
|===

Выберем самое большое количество циклов, т.е. 480 (биты 111 в поле SMP0 регистра ADC_SMPR2).

=== Цифровой фильтр

Согласно требованиям к ПО, к измеренному напряжению должен быть применен <<filter, цифровой фильтр>>.

Формула фильтра:

[%center]
[stem]
++++
tau = int  ((1-e^(-dt/(R*C)), RC > 0 sec), (1, RC<= 0 sec))

"FilteredValue" = "OldFiltered" + ("Value" - "OldValue") * tau,
++++

где dt -  100 мс; +
Value – текущее нефильтрованное измеренное значение напряжения; +
oldValue -  предыдущее фильтрованное значение.

Данный фильтр представляет собой экспоненциальный сглаживающий фильтр, имитирующий поведение аналогового RC-фильтра. Он часто используется для того, чтобы подавлять шумы в измерениях напряжения и других сигналов. 

Данный фильтр применяется в <<task1, высокоприоритетной задаче>> операционной системы реального времени.

=== Использование USART для передачи измеренных значений

<<UART, Согласно требованиям к ПО>>, передача измеренного напряжения должна передаваться по Bluetooth в заданном формате: *"Напряжение: " X.XXX [Units]*. Однако, поскольку информация на Bluetooth модуль поступает через UART, было решено использовать обычный UART для передачи данных на компьютер.

Читаться данные будут с помощью программы https://micro-pi.ru/terminal-1-9b-работаем-com-портом/[Terminal 1.9]. Формат байта UART в рамках курсового проекта можно выбрать стандартным, поскольку никаких дополнительных условий в требованиях к ПО не упоминалось:

[NOTE]
*1 стартовый бит + 8 бит данных + 1 стоповый бит, без проверки четности, режим дискретизации 1/16*

Также необходимо правильно выбрать скорость передачи данных. Скорость передачи данных в UART определяется значением, записанным в регистр *USART_BRR*. Это значение рассчитывается по следующей формуле:

[%center]
[stem]
++++
USARTDIV = f_CLK / (BaudRate * 8 (2 - OVER8)),
++++

где stem:[f_CLK] - системная частота; +
stem:[BaudRate] - желаемая скорость передачи данных, бод; +
stem:[OVER8] - значение, записанное в поле OVER8 регистра USART_CR1 (режим дискретизации).

Существует несколько стандартных скоростей передачи данных: 9600 бод, 19200 бод, 38400 бод, 57600 бод, 115200 бод. Поскольку было решено передавать данные по UART раз в 100 мс, то большая скорость передачи данных не требуется.

Рассчитаем время передачи одной строки <<output_format, заданного формата>> (19 символов) по формуле:

[%center]
[stem]
++++

++++

Рассчитаем значение, которое необходимо записать в регистр *USART_BRR*.

[%center]
[stem]
++++
USARTDIV = 8000000 / (16 * 9600) = 52,08333.
++++

Целая часть - 52, дробная часть - 0,08333.

В поле *DIV_Mantissa* регистра *USART_BRR* записывается 52 (0x340), в поле *DIV_Fraction* записывается округленное до ближайшего целого значение дробной части, т.е. 1 (0x001). Итого в регистр *USART_BRR* требуется записать значение *0x341*.

Рассчитаем 


=== Таблицы регистров для настройки

[[table_RCC]]
.Настройки регистров тактирования
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.3+| RCC_CR | HSEON (16) | 1 | Включить тактирования от внешнего кварцевого генератора (8 МГц)
| HSERDY (17) | Зависит от готовности | Устанавливается в 1, когда генератор стабилен и готов к работе
| HSION (0) | 0 | Отключить внутренний генератор (16 МГц) после того, как HSE включится
| RCC_CFGR | SW (1 : 0) | 01 | Выбрать HSE в качестве системной частоты
.2+| RCC_AHB1ENR | GPIOAEN (0) | 1 | Подать тактирование на порт GPIOA
| DMA2EN (22) | 1 | Подать тактирование на контроллер DMA2
| RCC_APB1ENR | USART2EN (17) | 1 | Подать тактирование на USART2
| RCC_APB2ENR | ADC1EN (8) | 1 | Подать тактирование на АЦП
|===

[[table_GPIO]]
.Настройки регистров GPIO
|===
.3+| GPIOA_MODER | MODER0 (1 : 0) | 11 | Установить пин PA0 в режим аналогового входа (для АЦП)
| MODER2 (5 : 4) | 10 | Установить пин PA2 в режим альтернативной функции (для UART TX)
| MODER3 (7 : 6) | 10 | Установить пин PA2 в режим альтернативной функции (для UART RX)
|===

[[table_ADC]]
.Настройки регистров для АЦП в режиме непрерывного преобразования
|===
| Регистр | Поле (номера битов) | Значение | Назначение
| ADC_CR1 | RES (25 : 24) | 00 | Установить разрядность АЦП (12 бит)
.3+| ADC_CR2 | EOCS (10) | 1 | Установить тип окончания преобразования: Бит Окончания преобразования EOC устанавливается после окончания преобразования для каждого канала
| CONT (1) | 1 | Установить режим непрерывного преобразования
| DMA (8) | 1 | Включить режим DMA
| ADC_SQR1 | L (3 : 0) | 0000 | Установить количество преобразований равным 1
| ADC_SQR3 | SQ1 (4 : 0) | 0000 | Выбрать канал 0 для измерения
| ADC_SMPR2 | SMP0 (2: 0) | 111 | Установить время преобразования на 480 циклов
.2+| ADC_CR2 | ADON (0) | 1 | Запуск АЦП
| SWSTART (30) | 1 | Начать преобразование
| ADC_DR | DATA (15 : 0) | Переменное | Используется для считывания преобразованных данных
|===

[[table_DMA]]
.Регистры для настройки DMA
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.8+| DMA_S0CR | CHSEL (27 : 25) | 000 | Выбор канала 0
| DIR (7 : 6) | 00 | Направление передачи данных: от периферии к памяти
| CIRC (8) | 1 | Циклический режим включен (т.к. непрерывное преобразование)
| MINC (10) | 0 | Отключить инкремент адреса памяти (для записи одного значения)
| PINC (9) | 0 | Отключить инкремент адреса периферии (т.к. адрес АЦП фиксирован)
| PSIZE (12 : 11) | 01 | Установить размер данных периферии 16 бит (поскольку АЦП 12-битный)
| MSIZE (14 : 13) | 01 | Установить размер данных памяти 16 бит
| EN (0) | 1 или 0 | Перед настройкой DMA бит установить в 0, после настройки запустить поток и установить бит в 1
| DMA_S0PAR | PAR (31 : 0) | Адрес регистра ADC_DR | Хранит адрес АЦП
| DMA_S0MA0R | MDA (31 : 0) | Адрес памяти, куда данные будут записываться | Хранит адрес памяти, куда сохраняется результат измерений
| DMA_S0NDTR | NDT (15 : 0) | Количество данных для передачи | Хранит количество передаваемых данных
| DMA_LIFCR | CTCIF0 (5) | 1 или 0 | Сбросить флаг завершения передачи DMA
| DMA_LISR | TCIF0 (5) | 1 или 0 | Ожидание завершения передачи DMA
|===

[[table_USART]]
.Регистры для настройки UART
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.5+| USART_CR1 | UE (13) | 1 | Включить UART
| TE (3) | 1 | Разрешить передачу
| M (12) | 0 | Установить формат передаваемого байта: 1 стартовый бит + 8 бит данных
| PCE (10) | 0 | Отключить четность
| OVER8 (15) | 0 | Установить дискретизацию 1/16
| USART_CR2 | STOP (13 : 12) | 00 | 1 стоп-бит
| USART_BRR | Все | (52 << 4) \| 1 | Скорость передачи 9600 бод
|===