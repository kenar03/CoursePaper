:description: Курсовой проект
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:imagesdir: media
:important-caption: ВАЖНО!
:note-caption: ПРИМЕЧАНИЕ
:stem: latexmath

= Курсовой проект
:sectnums: |,all|

include::titul.adoc[]

include::course_task.adoc[]

== Требования к ПО

* Для разработки должна использоваться отладочная плата https://www.waveshare.com/product/arduino-2/boards-kits/nucleo/xnucleo-f411re.htm[XNUCLEO-F411RE]
* Софт должен измерять напряжения с переменного резистора, уставленного на плате расширения
** Для измерения напряжения должен использоваться встроенный АЦП
** [[period]] Период измерения должен быть 50 ms
** [[DMA]] Для получения кода измерения должен использоваться механизм DMA
** Для изменения напряжения должна использоваться плата https://www.waveshare.com/product/arduino-2/shields/others/accessory-shield.htm[Accessories Shield] или https://www.waveshare.com/product/arduino-2/shields/others/analog-test-shield.htm[Analog Test Shield]
** Точность измерения напряжения должна быть не менее 0,01 вольта
** [[filter]] К измеренному напряжению должен быть применен цифровой фильтр вида: +

[%center]
[latexmath]
++++
\tau = \begin{cases} 
1 - e^{-\frac{dt}{RC}}, & RC > 0~\text{сек} \\
1, & RC \leq 0~\text{сек}
\end{cases} \\
FilteredValue = OldValue + (Value - OldValue) \cdot \tau
++++

где dt -  100 мс; +
Value – текущее нефильтрованное измеренное значение напряжения; +
oldValue -  предыдущее фильтрованное значение.

* [[leds]] Индикация значения измеренного напряжения должна осуществляться через включение/выключение светодиодов
** При максимальном напряжении софт должен зажигать 4 светодиода, при минимальном все светодиоды должны погаснуть.
** Промежуточные значения напряжения должны индицироваться следующим образом.
*** При 0-25% от максимального напряжения зажигается только 1 светодиод
*** При 25-50% от максимального напряжения зажигается только 2 светодиода
*** При 50-75% от максимального напряжения зажигается только 3 светодиода
*** При 75-100% от максимального напряжения зажигается все 4 светодиода

* [[UART]] Передача значений по беспроводному интерфейсу должна осуществляться через модуль https://elecfreaks.com/estore/download/EF03073-Bluetooth_Bee_(HC-05_and_HC-06)User_Guide.pdf[BlueTooth Bee HC-06]
 или https://www.waveshare.com/product/arduino-2/shields/others/io-expansion-shield.htm[I/O Expansion Shield]
** Общение с платой расширения должно осуществляться через USART2
** [[output_format]] формат вывод: +
   "Отфильтрованное напряжение: " X.XXX [Units] +
   "Неотфильтрованное апряжение: " X.XXX [Units]
* Архитектура должна быть представлена в виде UML диаграмм в пакете Plant UML
* Приложение должно быть написано на языке С++ с использованием компилятора ARM 8.40.2

* [[RTOS]] При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и https://github.com/lamer0k/RtosWrapper[С++ обертка над ней]

== Анализ требований к ПО

=== Отладочная плата XNUCLEO-F411RE и плата расширения Accessory Shield

Отладочная плаата XNUCLEO-F411RE - это улучшенная версия отладочной платы STM32 Nucleo, созданная компанией Waveshare. Основана XNUCLEO-F411RE на микроконтроллере STM32F411RET6 с ядром ARM Cortex-4 и предназначена для создания проектов и прототипирования. 

.Отладочная плата XNUCLEO-F411RE
image::XNUCLEO-F411RE.jpg[]

Основные особенности платы XNUCLEO-F411RE:

* совместимость с Arduino;
* подключение по USB;
* наличие светодиодов и пользовательской кнопки.

В ходе выполнения курсового проекта используется плата расширения Accessory Shield.

.Плата расширения Accessory Shield
image::accessory_shield.jpg[]

Accessory Shield - это плата расширения совместимая с популярными платформами для разработки электронных приложений, такими как Arduino UNO, Arduino Leonardo, NUCLEO, XNUCLEO и совместимыми. На плате установлены самые популярные дочерние модули, подходящие для реализации большинства задач.

Особенности платы расширения:

* разъем для подключения плат Arduino;
* разъем XBee для подключения беспроводных модулей;
* OLED дисплей 0,96 дюймов с разрешением 128x64 пикселей;
* RGB-светодиод;
* зуммер;
* потенциометр 10 кОм;
* 3-осевой цифровой акселерометр ADXL345;
* температурный датчик LM75BDP,
* джойстик 5-ти позиционный,
* индикатор состояния XBee,
* индикатор питания,
* кнопка сброса модулей XBee и Arduino,
* часы реального времени (RTC),
* держатель батареи CR1220 для RTC,
* драйвер RGB светодиода,
* джампер выбора режима Отладка/Связь.

=== Софт должен измерять напряжение с переменного резистора, установленного на плате расширения

Переменный резистор, установленный на плате расширения, согласно спецификации Waveshare, подключен к аналоговому входу микроконтроллера, пин *PA0*.

.Распиновка XNUCLEO-F411RE
image::xnucleo_spec.jpg[]

В плате расширения используется линейный потенциометр с тремя выводами:

* один крайний вывод подключен в питанию (стандартное напряжение питания, необходимо определить точно с помощью прецизионного мультиметра);
* другой крайний вывод подключен к земле;
* центральный вывод выведен на аналоговый вход микроконтроллера (пин PA0).

Таким образом, при вращении ручки потенциометра напряжение на центральном выводе изменяется от 0 В до 3,3 В.

Поскольку напряжение - аналоговый сигнал, его нужно измерять с помощью аналого-цифрового преобразователя (АЦП).

=== Для измерения напряжения должен использоваться встроенный АЦП с использованием DMA

Микроконтроллер STM32F411RET6 оснащен 12-битным АЦП, поддерживающим 19 каналов и позволяющим имзерять сигналы из 16 внешних источников, 2 внутренних источников, а также канал VBAT (измерение напряжения на линии питания резервной батареи).

Аналого-цифровое преобразование каналов может осуществляться в следующих режимах:

* Single Mode (однократное преобразование) - для выбранного канала преобразование выполняется один раз и останавливается после завершения.
* Continuous Mode (непрерывное преобразование) - автоматическое повторение преобразования выбранного канала без необходимости повторного запуска.
* Scan Mode (режим сканирования) - АЦП выполняет преобразование для группы каналов, заданных в последовательности, по одному за раз. Этот режим не является самостоятельным, а комбинируется с Single или Continuous.
* Discontinuous Mode (Прерывистый режим) - улучшенный режим  сканирования. Разбивает последовательность каналов на подгруппы. АЦП выполняет преобразование заданного числа каналов за один цикл, затем останавливается до следующего триггера.

Поскольку, <<DMA, согласно требованиям к ПО>>, требуется использовать механизм DMA совместно с АЦП, следует использовать режим непрерывного преобразования. АЦП будет передавать считанные значения с помощью DMA автоматически по выбранному адресу, без использования ядра процессора.

Для того, чтобы настроить АЦП в режиме непрерывного преобразования  и использовать его вместе с DMA, нужно:

. подать тактирование на порт, который будет использоваться для считывания данных с АЦП;
. настроить порт, подключенный к нужному каналу АЦП, на аналоговый вход;
. подать тактирование на АЦП;
. настроить разрешение АЦП;
. настроить режим преобразования (регистр ADC_CR2);
. установить количество каналов для опроса (поле L регистра ADC_SQR1);
. выбрать нужный канал для измерения;
. настроить канал АЦП на необходимую частоту преобразования;
. подать тактирование на модуль DMA;
. выбрать поток и канал DMA, соответствующие используемому АЦП;
. указать адрес источника DMA (регистр данных АЦП, ADC_DR);
. указать адрес назначения DMA (буфер в памяти для хранения данных);
. настроить размер данных и направление передачи;
. установить количество данных (размер буфера);
. включить режим циклической передачи DMA (для непрерывного измерения);
. включить запрос DMA в АЦП (бит DMA в регистре ADC_CR2);
. включить АЦП;
. начать преобразование АЦП (бит ADSTART в регистре ADC_CR2).

В <<table_ADC, данной таблице>> показаны настройки регистров, необходимых для включения АЦП в режиме непрерывного преобразования.

<<DMA, Согласно требованиям к ПО>>, для получения кода измерения должен использоваться механизм DMA. DMA - это режим обмена данными между периферией и основной памятью, в котором центральный процессор не участвует. Для работы с DMA в микроконтроллер встроены специальные контроллеры DMA.

На микроконтроллере STM32F411RET6 имеется 2 контроллера DMA, каждый из которых имеет 8 каналов, каждый канал имеет 8 потоков, которые подключаются к конкретному периферийному устройству. Если установлен бит DMA регистра ADC_CR2, то по окончании преобразования АЦП генерирует запрос DMA. Контроллер DMA получит этот запрос по внутренней линии связи между периферией и DMA. Затем контроллер DMA считывает данные с АЦП (записанные в регистр ADC_DR) и записывает их в указанный адрес памяти.

В спецификации к микроконтроллеру имеется таблица запросов DMA.

.Таблица запросов DMA
image::DMA_Requests_Tables.png[]

Согласно этой таблице, для того, чтобы генерировать запросы от АЦП, следует использовать контроллер DMA2, канал 0, потоки 0 или 4. В данной работе используется поток 0.

В <<table_DMA, данной таблице>> показана конфигурация регистров DMA для данного проекта.

Алгоритм настройки потока DMA представлен в пункте 9.3.17 в https://www.st.com/resource/en/reference_manual/rm0383-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf[Reference Manual] к STM32F411RET6.

image::DMA_algorythm1.png[]
.Алгоритм настройки потока DMA
image::DMA_algorythm2.png[]

=== Индикация измеренного напряжения светодиодами

<<leds, Согласно требования к ПО>>, индикация измеренного напряжения должна производиться так:

[cols="^,^"]
.Индикация измеренного напряжения светодиодами в зависимостит от положения ручки переменного резистора
|===
| % от максимального напряжения | Количество светодиодов
| 0-25 | 1
| 25-50 | 2
| 50-75 | 3
| 75-100 | 4
|===

Для расчета количества светодиодов предлагается использовать следующую формулу:

[[leds_equ]]
[%center]
[latexmath]
++++
LED_{curr} = \lceil\frac{V_{ADC} \cdot LED_{max}}{V_{ref}}\rceil,
++++

где latexmath:[V_{ADC}] - измеренное АЦП напряжение;
latexmath:[LED_{max} = 4] - количество светодиодов на плате;
latexmath:[V_{ref}] - опорное напряжение.

=== Периодичность измерений 50 мс с использованием операционной системы реального времени FreeRTOS

Поскольку, <<period, согласно требованиям к ПО>>, измерения необходимо производить с заданной периодичностью (50 мс), целесообразно использовать операционную систему реального времени.

Операционная система реального времени (ОСРВ) — это ОС, которая предназначена для обработки данных и выполнения задач в строго заданные временные рамки. Она гарантирует, что критически важные процессы завершатся вовремя, минимизируя задержки.

<<RTOS, Согласно требованиям к ПО>>, должна использоваться операционная система реального времени FreeRTOS и обертка над ней. *FreeRTOS* — это компактная операционная система реального времени (ОСРВ) с открытым исходным кодом, предназначенная для встраиваемых систем и микроконтроллеров. Она предоставляет базовые функции для управления задачами, планирования, синхронизации (семафоры, мьютексы, очереди) и работы с ограниченными ресурсами. Под *оберткой* понимается программный слой или библиотека, которая упрощает взаимодействие с FreeRTOS, скрывая её низкоуровневые детали и упрощая разработку.

Так как АЦП и DMA после настройки работают независимо от ядра микроконтроллера, создавать задачу для организации передачи данных между ними не нужно.

В данной таблице представлены задачи, которые выполняются операционной системой реального времени.

[cols="^,^,^,^"]
.Задачи, выполняемые операционной системой реального времени
|===
| Задача | Описание | Периодичность | Приоритет
| [[task1]] Расчет считанного значения напряжения, переданного по DMA | Читает счеты АЦП из ячеек памяти, куда пишет DMA; переводит счеты АЦП в напряжение; выполняет фильтрацию; управляет светодиодами | 50 мс | Высокий
| Передача данных по UART | Считывает значения, полученные из первой задачи и отправляет их по UART в заданном формате | 500 мс | Низкий
|===

Т.к. UART посылает данные реже, чем происходят измерения, можно использовать один и тот же объект для двух задач, блокируя его примитивом синхронизации. Однако, поскольку передаются всего лишь 2 числа в формате *float*, а этот формат состоит из 4 байт, передающихся атомарно, необходимости использовать блокировку нет. Поэтому, в данной работе решено использовать эти числа без блокировки.

=== Обеспечение точности не менее 0,01 В

Для того, чтобы обеспечить измерение напряжения с требуемой точностью, необходимо обеспечить корректную работу АЦП в непрерывном режиме с передачей данных через DMA.

Точность измерения напряжения определяется следующими факторами:

. Разрешение АЦП: Количество бит влияет на шаг квантования (latexmath:[\Delta V])
. Опорное напряжение: Задает диапазон измерений
. Частота АЦП: Влияет на длительность выборки  преобразования

==== Выбор параметров тактирования

Поскольку в требованиях к ПО не сказано, каким должно быть потребление ресурсов, было решено использовать внешний кварцевый генератор с частотой тактирования 8 МГц. Его будет достаточно для выполнения всех задач.

==== Выбор разрешения АЦП

В STM32F411RET6 АЦП поддерживает разрешения 6, 8, 10 и 12 бит. Формула расчета шага квантования:

[%center]
[latexmath]
++++
\Delta V = \frac{V_{ref}}{2^n},
++++

где latexmath:[V_{ref} = 3,3 V] - опорное напряжение;
   latexmath:[n] - разрядность АЦП.

Рассмотрим варианты квантования при различных разрешениях.

При latexmath:[n] = 8 бит:

[%center]
[latexmath]
++++
\Delta V = \frac{3,3}{2^8} = \frac{3,3}{256} = 12,891 mV
++++

При latexmath:[n] = 10 бит:

[%center]
[latexmath]
++++
\Delta V = \frac{3,3}{2^{10}} = \frac{3,3}{1024} = 3,223 mV
++++

При latexmath:[n] = 12 бит:

[%center]
[latexmath]
++++
\Delta V = \frac{3,3}{2^{12}} = \frac{3,3}{4096} = 0,806 mV
++++

Как можно заметить, 8 бит разрешения не достаточно для обеспечения требуемой точности. 10 бит хватает, но для обеспечения большей устойчивости к шумам следует выбрать разрешение *12 бит*, т.е. установить в регистре ADC_CR1 в поле RES биты 00.

==== Выбор времени преобразования АЦП

Время преобразования необходимо выбрать таким, чтобы оно было меньше заданного периода измерения, т.е. 50 мс.

Чем больше время преобразования, тем точнее преобразованное значение. Руководствуясь этим суждением, следует выбрать время преобразования, максимально близкое к 50 мс.

АЦП тактируется от шины APB2, частота которой в контексте данной задачи равна 8 МГц. В регистре ADC_CCR в поле ADCPRE настраивается значение предделителся частоты. Его минимальное значение составляет 2 (биты 00). Тогда, АЦП тактируется от частоты latexmath:[\frac{8 MHz}{2} = 4 MHz].

Время одного такта АЦП равно:

[%center]
[latexmath]
++++
T_{cycle} = \frac{1}{4 \cdot 10^6} = 0,25 μs.
++++

Время выборки АЦП определяется по формуле:

[%center]
[latexmath]
++++
T_{sample} = N_{sample} \cdot T_{cycle},
++++

где latexmath:[N_{sample}] - количество циклов выборки (настраивается в регистре ADC_SMPR2, поле SMP0).

Время преобразования АЦП определяется по формуле:

[%center]
[latexmath]
++++
T_{conversion} = (N_{sample} + N_{resolution}) \cdot T_{cycle},
++++
где latexmath:[N_{sample}] - количество циклов выборки (настраивается в регистре ADC_SMPR2, поле SMP0); latexmath:[N_{resolution}] - разрешение АЦП (было выбрано 12 бит).

Ниже рассчитаны различные значения времени преобразования в зависимости от количества циклов выборки.

[cols="^,^"]
.Расчет времени преобразования
|===
| latexmath:[N_{sample}] | latexmath:[T_{conversion}], мкс
| 3 | 3,75
| 15 | 6,75
| 28 | 10
| 56 | 17
| 84 | 24
| 112 | 31
| 144 | 39
| 480 | 123
|===

Выберем самое большое количество циклов, т.е. 480 (биты 111 в поле SMP0 регистра ADC_SMPR2).

==== Формула расчета напряжения

Для того, чтобы соблюсти требуемую точность, необходимо точно знать опорное напряжение latexmath:[V_{ref}]. Хотя номинально на плате напряжение питания равно 3,3 В, на самом деле оно не стабильно и может отклоняться от этого значения. Чтобы измежать этой нестабильности, необходимо осуществить калибровку.

Существует 2 пути калибровки:

* Измерять latexmath:[V_{ref}] с помощью специального канала АЦП и калиброваться от него.
* Измерить прецизионным мультиметром несколько экспериментальных точек, относительно которых будет осуществляться калибровка.

В данной работе калибровка осуществляется с помощью мультиметра.

Чтобы составить математическую модель, по которой будет осуществляться калибровка, необходимо также учесть влияние нелинейности АЦП на измерение напряжения. Согласно спецификации к STM32F411RET6, ошибки нелинейности АЦП зависят от частоты, при которой АЦП работает и становятся больше рпи ее увеличении:

.Ошибки нелинейности АЦП
image::ADC_Lin.png[]

Максимальная интегральная ошибка (т.е. отклонение максимальное отклонение реальной передаточной характеристики АЦП от идеальной прямой) составляет 6 LSB (минимально значащих битов). В вольтах:

[%center]
[latexmath]
++++
Error_{EL} = \Delta V \cdot 6 = 6 \cdot 0,806 = 4,836 mV.
++++

Максимальная дифференциальная ошибка (т.е. отклонение шага квантования от идеального) составляет 3 LSB. В вольтах:

[%center]
[latexmath]
++++
Error_{ED} = \Delta V \cdot 3 = 3 \cdot 0,806 = 2,418 mV.
++++

Как можно заметить, обе ошибки не превышают требуемой точности 10 мВ, т.е. можно считать, что нелинейность АЦП несущественна, и ей можно пренебречь. Тогда для калибровки можно использовать математическую модель, представляющую собой линейную функцию. Для составления такой модели достаточно измерить мультиметром всего 2 точки, а также зафиксировать соответствующие им счеты АЦП. В данной работе измеряются минимальное напряжение и максимальное напряжение.

Измерение точек производилось с помощью мультиметра FLUKE 17B. Были сняты следующие точки:

* Минимальное напряжение: 0,0001 В / 2 счета АЦП;
* Максимальное напряжение: 3,275 В / 4093 счета АЦП.

Формула преобразования счетов АЦП в напряжение с калибровкой показана ниже:

[[voltage_equ]]
[%center]
[latexmath]
++++
V_{ADC} = Gain \cdot ADC_{curr} + Offset,
++++

где latexmath:[Gain] - коэффициент усиления; +
latexmath:[Offset] - смещение; +
latexmath:[ADC_{curr}] - текущие счеты АЦП.

Коэффициент усиления определяется по формуле:

[%center]
[latexmath]
++++
Gain = \frac{ADC_{max} - ADC_{min}}{V_{max} - V_{min}},
++++
где latexmath:[ADC_{max} = 4093] - счеты АЦП, соответствующие максимальному напряжению; +
latexmath:[ADC_{min} = 2] - счеты АЦП, соответствующие минимальному напряжению; +
latexmath:[V_{max} = 3,275 В] - максимальное напряжение; +
latexmath:[V_{min} = 0,0001 В] - минимальное напряжение.

Смещение определяется по формуле:

[%center]
[latexmath]
++++
Offset = V_{max} - \frac{ADC_{max} - ADC_{min}}{V_{max} - V_{min}} \cdot ADC_{max}.
++++

=== Цифровой фильтр

Согласно требованиям к ПО, к измеренному напряжению должен быть применен <<filter, цифровой фильтр>>.

Формула фильтра:

[%center]
[latexmath]
++++
\tau = \begin{cases} 
1 - e^{-\frac{dt}{RC}}, & RC > 0~\text{сек} \\
1, & RC \leq 0~\text{сек}
\end{cases} \\
FilteredValue = OldValue + (Value - OldValue) \cdot \tau
++++

где dt -  100 мс; +
Value – текущее нефильтрованное измеренное значение напряжения; +
oldValue -  предыдущее фильтрованное значение.

Данный фильтр представляет собой экспоненциальный сглаживающий фильтр, имитирующий поведение аналогового RC-фильтра. Он часто используется для того, чтобы подавлять шумы в измерениях напряжения и других сигналов. 

Данный фильтр применяется в <<task1, высокоприоритетной задаче>> операционной системы реального времени.

Поскольку dt -  100 мс, фильтроваться будет каждое второе снятое с АЦП значение напряжения.

=== Использование USART для передачи измеренных значений

<<UART, Согласно требованиям к ПО>>, передача измеренного напряжения должна передаваться по Bluetooth в <<output_format, заданном формате>>. Однако, поскольку информация на Bluetooth модуль поступает через UART, было решено использовать обычный UART для передачи данных на компьютер. Передаваться будут отфильтрованное значение напряжения и неотфильтрованное значение напряжения.

Передача должна осуществляться по прерыванию.

Читаться данные будут с помощью программы https://putty.org.ru/download/[PuTTY-0.73]. Формат байта UART в рамках курсового проекта можно выбрать стандартным, поскольку никаких дополнительных условий в требованиях к ПО не упоминалось:

[NOTE]
*1 стартовый бит + 8 бит данных + 1 стоповый бит, без проверки четности, режим дискретизации 1/16*

Микроконтроллер STM32F411RET6 поддерживает несколько UART-модулей. в курсовом проекте решено использовать модуль UART2, поскольку на плате XNUCLEO-F411RE он аппаратно подключен к чипу CP2102, позволяющему передавать данные UART через USB на компьютер. В данном случае для UART используются пины *PA2 (RX)* и *PA3 (TX)*.

Также необходимо правильно выбрать скорость передачи данных. Она должна быть достаточной для того, чтобы успевать передавать данные, а также не должна иметь большую ошибку (между реальной скоростью и ожидаемой).

Существует несколько стандартных скоростей передачи данных: 9600 бод, 19200 бод, 38400 бод, 57600 бод, 115200 бод. Поскольку было решено передавать данные по UART раз в 100 мс, то большая скорость передачи данных не требуется.

Рассчитаем время передачи одной строки <<output_format, заданного формата>> (19 символов) по формуле:

[%center]
[latexmath]
++++
t_{transmit} = \frac{19 \cdot 10}{9600} = 19,79 ms.
++++

Как можно заметить, скорости 9600 бод вполне достаточно для того, чтобы передавать требуемую строку раз в 100 мс.

Скорость передачи данных в UART определяется значением, записанным в регистр *USART_BRR*. Это значение рассчитывается по следующей формуле:

[%center]
[latexmath]
++++
USARTDIV = \frac{f_{CLK}}{BaudRate \cdot 8 \cdot (2 - OVER8)},
++++

где latexmath:[f_{CLK}] - системная частота; +
latexmath:[BaudRate] - желаемая скорость передачи данных, бод; +
latexmath:[OVER8] - значение, записанное в поле OVER8 регистра USART_CR1 (режим дискретизации).

Чем больше скорость - тем меньше делитель *USARTDIV* и больше ошибка от округления значения, записываемого в регистр *USART_BRR*.

Рассчитаем значение, которое необходимо записать в регистр *USART_BRR*.

[%center]
[latexmath]
++++
USARTDIV = \frac{8000000}{16 \cdot 9600} = 52,08333.
++++

Целая часть - 52, дробная часть - 0,08333.

В поле *DIV_Mantissa* регистра *USART_BRR* записывается 52 (0x340), в поле *DIV_Fraction* записывается округленное до ближайшего целого значение дробной части, т.е. 1 (0x001). Итого в регистр *USART_BRR* требуется записать значение *0x341*.

Рассчитаем ошибку для этого значения. При этом записанный в регистр делитель равен:
latexmath:[USARTDIV = \frac{52 + 1}{16} = 52,0625]:

[%center]
[latexmath]
++++
Error = \left|\frac{V_{r} - V_{d}}{V_{d}}\right| \cdot 100 \%
= \left|\frac{(\frac{f_{CLK}}{16 \cdot 52,0625}) - 9600}{9600}\right| \cdot 100 \%
= \frac{9603,84 - 9600}{9600} \cdot 100 \%
= 0,04 \%.
++++

Таким образом, реально записанная в регистр *USART_BRR* скорость составляет 9603,84 бод, с ошибкой 0,04%.

=== Таблицы регистров для настройки

[[table_RCC]]
.Настройки регистров тактирования
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.3+| RCC_CR | HSEON (16) | 1 | Включить тактирования от внешнего кварцевого генератора (8 МГц)
| HSERDY (17) | Зависит от готовности | Устанавливается в 1, когда генератор стабилен и готов к работе
| HSION (0) | 0 | Отключить внутренний генератор (16 МГц) после того, как HSE включится
| RCC_CFGR | SW (1 : 0) | 01 | Выбрать HSE в качестве системной частоты
.2+| RCC_AHB1ENR | GPIOAEN (0) | 1 | Подать тактирование на порт GPIOA
| DMA2EN (22) | 1 | Подать тактирование на контроллер DMA2
| RCC_APB1ENR | USART2EN (17) | 1 | Подать тактирование на USART2
| RCC_APB2ENR | ADC1EN (8) | 1 | Подать тактирование на АЦП
|===

[[table_GPIO]]
.Настройки регистров GPIO
|===
.5+| GPIOA_MODER | MODER0 (1 : 0) | 11 | Установить пин PA0 в режим аналогового входа (для АЦП)
| MODER2 (5 : 4) | 10 | Установить пин PA2 в режим альтернативной функции (для UART TX)
| MODER3 (7 : 6) | 10 | Установить пин PA2 в режим альтернативной функции (для UART RX)
| AFRL2 | (11 : 7) | 0111 | Установить USART TX как альтернативную функцию для PA2
| AFRL3 | (15 : 12) | 0111 | Установить USART RX как альтернативную функцию для PA3
|===

[[table_ADC]]
.Настройки регистров для АЦП в режиме непрерывного преобразования
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.2+| ADC_CR1 | RES (25 : 24) | 00 | Установить разрядность АЦП (12 бит)
| SCAN (8) | 1 | Включить режим сканирования
.4+| ADC_CR2 | EOCS (10) | 1 | Установить тип окончания преобразования: Бит Окончания преобразования EOC устанавливается после окончания преобразования для каждого канала
| CONT (1) | 1 | Установить режим непрерывного преобразования
| DMA (8) | 1 | Включить режим DMA
| DDS (9) | 1 | Включить непрерывные запросы DMA
| ADC_SQR1 | L (3 : 0) | 0000 | Установить количество преобразований равным 1
| ADC_SQR3 | SQ1 (4 : 0) | 0000 | Выбрать канал 0 для измерения
| ADC_SMPR2 | SMP0 (2: 0) | 111 | Установить время преобразования на 480 циклов
.2+| ADC_CR2 | ADON (0) | 1 | Запуск АЦП
| SWSTART (30) | 1 | Начать преобразование
| ADC_DR | DATA (15 : 0) | Переменное | Используется для считывания преобразованных данных
|===

[[table_DMA]]
.Регистры для настройки DMA
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.8+| DMA_S0CR | CHSEL (27 : 25) | 000 | Выбор канала 0
| DIR (7 : 6) | 00 | Направление передачи данных: от периферии к памяти
| CIRC (8) | 1 | Циклический режим включен (т.к. непрерывное преобразование)
| MINC (10) | 0 | Отключить инкремент адреса памяти (для записи одного значения)
| PINC (9) | 0 | Отключить инкремент адреса периферии (т.к. адрес АЦП фиксирован)
| PSIZE (12 : 11) | 10 | Установить размер данных периферии 32 бит (поскольку регистр данных АЦП ADC_DR имеет размер 32 бита)
| MSIZE (14 : 13) | 10 | Установить размер данных памяти 32 бита
| EN (0) | 1 или 0 | Перед настройкой DMA бит установить в 0, после настройки запустить поток и установить бит в 1
| DMA_S0PAR | PAR (31 : 0) | Адрес регистра ADC_DR | Хранит адрес АЦП
| DMA_S0MA0R | MDA (31 : 0) | Адрес памяти, куда данные будут записываться | Хранит адрес памяти, куда сохраняется результат измерений
| DMA_S0NDTR | NDT (15 : 0) | Количество данных для передачи | Хранит количество передаваемых данных
|===

[[table_USART]]
.Регистры для настройки UART
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.5+| USART_CR1 | UE (13) | 1 | Включить UART
| TE (3) | 1 | Разрешить передачу
| M (12) | 0 | Установить формат передаваемого байта: 1 стартовый бит + 8 бит данных
| PCE (10) | 0 | Отключить четность
| OVER8 (15) | 0 | Установить дискретизацию 1/16
| USART_CR2 | STOP (13 : 12) | 00 | 1 стоп-бит
| USART_BRR | Все | (52 << 4) \| 1 | Скорость передачи 9600 бод
| USART_SR | TXE (7) | Переменное | Бит устанавливается, когда буфер передачи пуст. Срабатывает прерывание
| NVIC_ISER1 | 38 - 32 = 6 (номер в таблице векторов прерываний) | 1 | Разрешить прерывания для UART 
|===

== Разработка архитектуры ПО

.Общая архитектура проекта
[plantuml]
----
include::design/architecture_common.puml[]
----

.Полная архитектура проекта
[plantuml]
----
include::design/architecture_full.puml[]
----

<<period, Согласно требованиям к ПО>>, измерение напряжения происходит в задаче *MeasurementTask* раз в 50 мс. Задача *MeasurementTask* является медиатором, в котором связываются все классы, отвечающие непосредственно за снятие напряжения, фильтрацию и индикацию. Фильтрация напряжения в этой задаче осуществляется раз в 100 мс, т.е. фильтруется каждое второе значение.

Задача *UsartTask* выполняется раз в 500 мс и отвечает за форматирование и отправку сообщения по USART.

Обе задачи реализуют общий интерфейс *IThread* и выполняются независимо друг от друга.

Задача *MeasurementTask* отвечает за:

* сбор счетов АЦП, полученных по DMA (класс *AdcDmaDataProvider*);
* преобразование счетов АЦП в напряжение (класс *Voltage*);
* фильтрацию каждого второго полученного значения напряжения (класс *DigitalFilter*);
* сохранение отфильтрованного и неотфильтрованного значения в репозиторий (класс *DataRepository*);
* расчет количества светодиодов, показывающих текущее значение отфильтрованного напряжения (класс *LedCalculator*);
* индикацию светодиодами (класс *LedControler*).

Непосредственное управление светодиодами реализовано в шаблонном классе *LedSwitcher*, а индикация текущего напряжения - в классе *LedController*.

Задача *UsartTask* раз в 500 мс отправляет данные по USART. Она отвечает за:

* чтение неотфильтрованного и отфильтрованного напряжения из репозитория (класс *DataRepository*);
* форматирование напряжения в строку <<output_format, заданного формата>> (класс *Formatter*);
* отправку форматированных неотфильтрованного и отфильтрованного значений напряжения по USART с помощью глобального прерывания (класс *Usart*).

Разделим общую архитектуру проекта на смысловые блоки и опишем каждый.

=== Задачи

.Задачи
[plantuml]
----
include::design/thread_management_block.puml[]
----

Блок задач состоит из двух классов, реализующих интерфейс IThread.

==== Класс MeasurementTask

*MeasurementTask* - задача измерения. Раз в 50 мс берет значения счетов АЦП, переданных по DMA, переводит их в напряжение, фильтрует, заносит неотфильтрованное и отфильтрованное значения в репозиторий, расчитывает количество светодиодов, которые должны загореться и зажигает их.

Исходный код класса MeasurementTask:

.MeasurementTask.hpp
[source, cpp]
----
#ifndef MEASUREMENTTASK_HPP
#define MEASUREMENTTASK_HPP

#include "thread.hpp" //For OsWrapper::Thread
#include "IDigitalFilter.hpp" // for IDigitalFilter
#include "IVoltage.hpp" // for IVoltage
#include "ILedController.hpp"  // for ILedController
#include "ILedCalculator.hpp"  // for ILedCalculator
#include "IDataRepositoryUpdater.hpp" // for IDataRepositoryUpdater
#include "IRawDataProvider.hpp" // for IRawDataProvider

using namespace OsWrapper;

class MeasurementTask : public OsWrapper::Thread<512U>
{
public:
  MeasurementTask(IRawDataProvider& rawData, IDigitalFilter& filter, IVoltage& voltage,
                  ILedCalculator& ledCalculator, ILedController& ledController, IDataRepositoryUpdater& dataRepositoryUpdater);
  virtual void Execute() override;
private:
  IRawDataProvider& mRawData;
  IDigitalFilter& mDigitalFilter;
  IVoltage& mVoltage;
  ILedCalculator& mLedCalculator;
  ILedController& mLedController;
  IDataRepositoryUpdater& mDataRepositoryUpdater;
  bool mFilterEnabled = true;
  float mOldFilteredVoltage = 0.0f;
};

#endif
----

.MeasurementTask.cpp
[source, cpp]
----
#include "MeasurementTask.hpp" // for MeasurementTask

MeasurementTask :: MeasurementTask(IRawDataProvider& rawData, IDigitalFilter& filter, IVoltage& voltage,
                  ILedCalculator& ledCalculator, ILedController& ledController, IDataRepositoryUpdater& dataRepositoryUpdater) :
  mRawData(rawData),
  mDigitalFilter(filter),
  mVoltage(voltage),
  mLedCalculator(ledCalculator),
  mLedController(ledController),
  mDataRepositoryUpdater(dataRepositoryUpdater)
{
}

void MeasurementTask :: Execute()
{
  for(;;)
  {
    uint32_t currAdcCounts = mRawData.GetRawData();
    float rawVoltage = mVoltage.Measure();
    // Задача выполняется раз в 50 мс,т.е. флаг mFilterEnabled тоже изменяется раз в 50 мс
    // Тогда, в то же самое состояние флаг вернется через 100 мс, что соответствует dt
    if(mFilterEnabled)
    {
      mOldFilteredVoltage = mDigitalFilter.FilterValue(rawVoltage);
    }
    float filteredVoltage = mOldFilteredVoltage;
    mDataRepositoryUpdater.UpdateValue(rawVoltage);
    mDataRepositoryUpdater.UpdateFilteredValue(filteredVoltage);
    uint8_t currLedAmount = mLedCalculator.Calculate(filteredVoltage);
    mLedController.Indicate(currLedAmount);
    Sleep(50ms);
  }
}
----

==== Класс UsartTask

*UsartTask* - задача, отправляющая по USART строку заданного формата раз в 500 мс. Задача берет из репозитория неотфильтрованное и отфильтрованное значения напряжения, форматирует их в строку заданного формата и отправляет по USART.

Исходный код класса UsartTask:

.UsartTask.hpp
[source, cpp]
----
#ifndef USARTTASK_HPP
#define USARTTASK_HPP

#include "thread.hpp" //For OsWrapper::Thread
#include "IUsart.hpp" // for IUsart
#include "IDataRepositoryProvider.hpp" // for IDataRepositoryProvider
#include "IFormatter.hpp" // for IFormatter

class UsartTask : public OsWrapper::Thread<512U>
{
public:
  UsartTask(IDataRepositoryProvider& dataRepositoryProvider, IUsart& usart, IFormatter& formatter);
  virtual void Execute() override;
private:
  IUsart& mUsart;
  IDataRepositoryProvider& mDataRepositoryProvider;
  IFormatter& mFormatter;
};

#endif
----

.UsartTask.cpp
[source, cpp]
----
#include "UsartTask.hpp" // for UsartTask

UsartTask :: UsartTask(IDataRepositoryProvider& dataRepositoryProvider, IUsart& usart, IFormatter& formatter) :
  mDataRepositoryProvider(dataRepositoryProvider),
  mUsart(usart),
  mFormatter(formatter)
{
}

void UsartTask :: Execute()
{
  for(;;)
  {
    const auto currVoltage = mDataRepositoryProvider.GetValue();
    const auto currFilteredVoltage = mDataRepositoryProvider.GetFilteredValue();
    const auto voltageString = mFormatter.FormatString(currVoltage, 3U, " В", false);
    mUsart.SendMessage(voltageString);
    while(mUsart.IsBusy())
    {
      SleepUntil(1ms);
    }
    const auto filteredVoltageString = mFormatter.FormatString(currFilteredVoltage, 3U, " В", true);
    mUsart.SendMessage(filteredVoltageString);
    SleepUntil(500ms);
  }
}
----

=== Измерение данных

.Блок измерения данных
[plantuml]
----
include::design/data_measurement_block.puml[]
----

Блок измерения данных состоит из классов *AdcDmaDataProvider* и *Voltage*.

==== Класс AdcDmaDataProvider

Класс *AdcDmaDataProvider* наследуется от интерфейса *IRawDataProvider* и выполняет функцию получения счетов АЦП, переданных по DMA, а также конфигурацию АЦП и DMA.

Исходный код класса *AdcDmaDataProvider* и интерфейса *IRawDataProvider*:

.IRawDataProvider.hpp
[source, cpp]
----
#ifndef IRAWDATAPROVIDER_HPP
#define IRAWDATAPROVIDER_HPP

class IRawDataProvider
{
public:
  virtual std::uint32_t GetRawData() = 0;
};

#endif
----

.AdcDmaDataProvider.hpp
[source, cpp]
----
#ifndef ADCDMADATAPROVIDER_HPP
#define ADCDMADATAPROVIDER_HPP

#include "adc1registers.hpp"   // for ADC1
#include "adccommonregisters.hpp"  // for ADC
#include "dma2registers.hpp"     // For DMA2
#include "IRawDataProvider.hpp"      // for IRawDataProvider

class AdcDmaDataProvider : public IRawDataProvider
{
public:
  AdcDmaDataProvider();
  std::uint32_t GetRawData() override;
  void ConfigAdc();
private:
  std::uint32_t data;
  void ConfigDma();
};

#endif
----

.AdcDmaDataProvider.cpp
[source, cpp]
----
#include "AdcDmaDataProvider.hpp"   // for AdcDmaDataProvider

AdcDmaDataProvider :: AdcDmaDataProvider() : data(0)
{
}

void AdcDmaDataProvider :: ConfigDma()
{
  DMA2::S0CR::EN::Value0::Set();
  DMA2::S0CR::CHSEL::Value0::Set();
  DMA2::S0CR::MSIZE::Value2::Set();
  DMA2::S0CR::PSIZE::Value2::Set();
  DMA2::S0CR::CIRC::Value1::Set();
  DMA2::S0CR::MINC::Value0::Set();
  DMA2::S0CR::PINC::Value0::Set();
  DMA2::S0CR::DIR::Value0::Set();
  DMA2::S0PAR::Write(ADC1::DR::Address);
  DMA2::S0M0AR::Write(reinterpret_cast<std::uint32_t>(&data));
  DMA2::S0NDTR::Write(1);
  DMA2::S0CR::EN::Value1::Set();
};

void AdcDmaDataProvider :: ConfigAdc()
{
  ConfigDma();
  ADC1::CR1::RES::Bits12::Set();
  ADC1::CR2::EOCS::SingleConversion::Set();
  ADC1::CR1::SCAN::Enable::Set();
  ADC1::CR2::CONT::ContinuousConversion::Set();
  ADC1::CR2::DMA::Enable::Set();
  ADC1::SQR1::L::Conversions1::Set();
  ADC1::SQR3::SQ1::Channel0::Set();
  ADC1::SMPR2::SMP0::Cycles480::Set();
  ADC1::CR2::DDS::DMARequest::Set();
  ADC1::CR2::ADON::Enable::Set();
  ADC1::CR2::SWSTART::On::Set();
};

std::uint32_t AdcDmaDataProvider :: GetRawData()
{
  return static_cast<std::uint32_t>(data);
};
----

==== Класс Voltage

Класс *Voltage* отвечает за преобразование счетов АЦП в напряжение по <<voltage_equ, формуле>>, представленной в разделе "Анализ требований к ПО". Этот класс наследуется от интерфейса *IVoltage*.

Для того, чтобы обеспечить гибкость, универсальность и быстродействие, класс *Voltage* сделан шаблонным. Он принимает в качестве шаблонных параметров калибровочные точки напряжения, измеренные с помощью мультиметра, и соответствующие этим точкам счеты АЦП.

.IVoltage.hpp
[source, cpp]
----
#ifndef IVOLTAGE_HPP
#define IVOLTAGE_HPP

class IVoltage
{
public:
  virtual float Measure() = 0;
};

#endif
----

.Voltage.hpp
[source, cpp]
----
#ifndef VOLTAGE_HPP
#define VOLTAGE_HPP

#include "IRawDataProvider.hpp" // for IRawDataProvider
#include "IVoltage.hpp" // for IVoltage

template<const uint32_t& maxAdcCounts, const uint32_t& minAdcCounts, const float& maxVoltage, const float& minVoltage>
class Voltage : public IVoltage
{
public:
  Voltage(IRawDataProvider& data) : mData(data)
  {
  }
  float Measure()
  {
    auto voltageValue = CalculateGain() * (static_cast<float>(mData.GetRawData())) + CalculateOffset();
    return voltageValue;
  }
private:
  float CalculateGain()
  {
    float gain = static_cast<float>((maxVoltage - minVoltage) / (maxAdcCounts - minAdcCounts));
    return gain;
  }
  float CalculateOffset()
  {
    float offset = static_cast<float>(maxVoltage - CalculateGain() * maxAdcCounts);
    return offset;
  }
  
  IRawDataProvider& mData;
};

#endif
----

=== Фильтрация данных

.Блок фильтрации данных
[plantuml]
----
include::design/data_filtering_block.puml[]
----

Блок фильтрации данных состоит из класса *DigitalFilter*, наследуемого от интерфейса *IDigitalFilter*.

==== Класс DigitalFilter

Класс *DigitalFilter* осуществляет фильтрацию напряжения с помощью <<filter, цифрового фильтра>>.

.IDigitalFilter.hpp
[source, cpp]
----
#ifndef IDIGITALFILTER_HPP
#define IDIGITALFILTER_HPP

class IDigitalFilter
{
public:
  virtual float FilterValue(float value) = 0;
};

#endif
----

.DigitalFilter.hpp
[source, cpp]
----
#ifndef DIGITALFILTER_HPP
#define DIGITALFILTER_HPP

#include "IDigitalFilter.hpp" // for IDigitalFilter

class DigitalFilter : public IDigitalFilter
{
public:
  DigitalFilter(const float& dt, const float& rc);
  float FilterValue(float value) override;
private:
  const float& dt;
  const float& rc;
  float oldValue;
  bool isFirstTime;
};

#endif
----

.DigitalFilter.cpp
[source, cpp]
----
#include "DigitalFilter.hpp" // for DigitalFilter
#include <cmath> // for std::exp

DigitalFilter::DigitalFilter(const float& dt, const float& rc)
: dt(dt), rc(rc), oldValue(0.0f), isFirstTime(true) {}

float DigitalFilter::FilterValue(float value)
{
  if (isFirstTime)
  {
    oldValue = value;
    isFirstTime = false;
    return value;
  }
  
  float tau = 1.0f - std::exp(-dt / rc);
  float filteredValue = oldValue + (value - oldValue) * tau;
  oldValue = filteredValue;
  return filteredValue;
}
----

=== Управление светодиодами

.Блок управления светодиодами
[plantuml]
----
include::design/led_control_block.puml[]
----

Индикация светодиодами осуществляется двумя независимыми друг от друга классами *LedCalculator* и *LedController*. Непосредственное включение и выключение светодиодов осуществляет шаблонный класс *LedSwitcher*, связанный с классом *LedController* через интерфейс *ILedSwitcher*.

==== Класс LedSwitcher

Класс *LedSwitcher* является шаблонным и отвечает за непосредственное включение и выключение отдельного светодиода. Для удобства светодиоды обновляются в массив, который объявлен в файле *LedConfig.hpp*.

.ILedSwitcher.hpp
[source, cpp]
----
#ifndef ILEDSWITCHER_H
#define ILEDSWITCHER_H

class ILedSwitcher
{
public:
  virtual void Light() = 0;
  virtual void Off() = 0;
  virtual void Toggle() = 0;
};

#endif
----

.LedsConfig.hpp
[source, cpp]
----
#ifndef LEDCONFIG_H
#define LEDCONFIG_H
#include <array> // for std::array
#include "ILedSwitcher.hpp" // for ILedSwitcher

using tLeds = std::array<ILedSwitcher*, 4>;

#endif
----

.LedSwitcher.hpp
[source, cpp]
----
#ifndef LEDSWITCHER_H
#define LEDSWITCHER_H

#include "ILedSwitcher.hpp" // for ILedSwitcher

template<typename Tport, int pinNumber>
class LedSwitcher : public ILedSwitcher
{
public:        
  void Light() override
  {
    Tport::ODR::Set(1 << pinNumber);
  }
  
  void Off() override
  {
    Tport::ODR::Write(Tport::ODR::Get() &~ (1 << pinNumber));
  }
  
  void Toggle() override {
    Tport::ODR::Toggle(1 << pinNumber);
  }
};

#endif
----

==== Класс LedCalculator

Класс *LedCalculator* осуществляет <<leds_equ, расчет>> количества светодиодов, которые должны загореться, в зависимости от напряжения. Он наследуется от интерфейса *ILedCalculator*. Максимальное количество светодиодов на плате и напряжение питания задаются извне класса по ссылке.

.ILedCalculator.hpp
[source, cpp]
----
#ifndef ILEDCALCULATOR_HPP
#define ILEDCALCULATOR_HPP

#include <cstdint> // for std::uint8_t

class ILedCalculator
{
public:
  virtual uint8_t Calculate(float adcVoltage) = 0;
};

#endif
----

.LedCalculator.hpp
[source, cpp]
----
#ifndef LEDCALCULATOR_HPP
#define LEDCALCULATOR_HPP

#include "ILedCalculator.hpp" // for ILedCalculator

class LedCalculator : public ILedCalculator
{
public:
  LedCalculator(const uint8_t& maxLedAmount, const float& maxVoltage);
  uint8_t Calculate(float adcVoltage) override;
private:
  const uint8_t& mMaxLedAmount;
  const float& mVref;
};

#endif
----

.LedCalculator.cpp
[source, cpp]
----
#include "LedCalculator.hpp" // for LedCalculator
#include <cmath> // for std::ceil

LedCalculator::LedCalculator(const uint8_t& maxLedAmount, const float& maxVoltage) : mMaxLedAmount(maxLedAmount), mVref(maxVoltage)
{}

uint8_t LedCalculator::Calculate(float adcVoltage)
{
  uint8_t ledAmount = static_cast<uint8_t>(std::ceil((adcVoltage * mMaxLedAmount) / mVref));
  if (ledAmount > mMaxLedAmount)
  {
    ledAmount = mMaxLedAmount;
  }
  return ledAmount;
}
----

==== Класс LedController

Класс *LedController* осуществляет <<leds, управление непосредственно светодиодами>>. У него есть единственный метод *Indicate*, который принимает в качестве аргумента количество светодиодов, которые необходимо включить. Этот класс наследуется от интерфейса *ILedCalculator*. Логика включения светодиодов описана в классе *LedSwitcher*.

.ILedController
[source, cpp]
----
#ifndef ILEDCONTROLLER_HPP
#define ILEDCONTROLLER_HPP

#include <cstdint> // for std::uint8_t

class ILedController
{
public:
  virtual void Indicate(uint8_t ledAmount) = 0;
};

#endif
----

.LedController.hpp
[source, cpp]
----
#ifndef LEDCONTROLLER_HPP
#define LEDCONTROLLER_HPP

#include "ILedController.hpp" // for ILedController
#include "LedConfig.hpp" // for tLeds

class LedController : public ILedController
{
public:
  LedController(tLeds& ledsArr, const uint8_t& maxLedAmount);
  void Indicate(uint8_t ledAmount) override;
private:
  tLeds& leds;
  const uint8_t& mMaxLedAmount;
};

#endif
----

.LedController.cpp
[source, cpp]
----
#include "LedController.hpp" // for LedCalculator

LedController::LedController(tLeds& ledsArr, const uint8_t& maxLedAmount) : leds(ledsArr), mMaxLedAmount(maxLedAmount)
{
}

void LedController::Indicate(uint8_t ledAmount)
{ 
  for(uint8_t i = 0; i < mMaxLedAmount; ++i)
  {
    if(i < ledAmount)
    {
      leds[i]->Light();
    }
    else
    {
      leds[i]->Off();
    }
  }
}
----

=== Коммуникация

.Блок коммуникации
[plantuml]
----
include::design/communication_block.puml[]
----

Блок коммуникации состоит из двух классов: класса *Usart* и класса *Formatter*.

==== Класс Usart

Класс *Usart* предоставляет методы для работы с USART. Так, он имеет методы:

* *Instance()* - предоставляет доступ к единственному экземпляру этого класса из любой точки кода (паттерн Singleton).
* *ConfigUsart()* - настраивает USART для работы.
* *SendMessage()* - копирует в общий буфер сообщение, которое необходимо отправить, и отправляет первый байт для того, чтобы активировать прерывание.
* *IsBusy()* - проверяет, завершена ли отправка сообщения.
* *HandleInterrupt()* - осуществляет отправку сообщения с помощью прерывания.

Класс *Usart* наследуется от интерфейса *IUsart*.

.IUsart.hpp
[source, cpp]
----
#ifndef IUSART_HPP
#define IUSART_HPP

#include <string> // for std::string

class IUsart
{
public:
  virtual void SendMessage(const char* message) = 0;
  virtual bool IsBusy() = 0;
};

#endif
----

.Usart.hpp
[source, cpp]
----
#ifndef USART_HPP
#define USART_HPP

#include "IUsart.hpp" // for IUsart

class Usart : public IUsart
{
public:
  static Usart& Instance();
  Usart();
  void ConfigUsart();
  void SendMessage(const char* message) override;
  bool IsBusy() override;
  void HandleInterrupt();

private:
  static constexpr std::size_t mBufferCapacity = 128;
  char mBuffer[mBufferCapacity];
  std::size_t mBufferLength;
  std::size_t mIndex;
};

#endif
----

.Usart.cpp
[source, cpp]
----
#include "Usart.hpp"
#include "gpioaregisters.hpp"
#include "usart2registers.hpp"
#include "nvicregisters.hpp"
#include <cmath>

Usart& Usart::Instance()
{
  static Usart inst;
  return inst;
}

Usart::Usart() : mBufferLength(0), mIndex(0)
{}

void Usart::ConfigUsart()
{
  GPIOA::MODER::MODER2::Alternate::Set();
  GPIOA::MODER::MODER3::Alternate::Set();
  GPIOA::AFRL::AFRL2::Af7::Set();
  GPIOA::AFRL::AFRL3::Af7::Set();

  USART2::CR1::OVER8::OversamplingBy16::Set();
  USART2::CR1::M::Data8bits::Set();
  USART2::CR1::PCE::ParityControlDisable::Set();
  USART2::CR2::STOP::Value0::Set();

  constexpr uint32_t SystemCoreClock = 8'000'000;
  constexpr uint32_t BaudRate        = 9'600U;
  double divisor = static_cast<double>(SystemCoreClock) / (BaudRate * 16.0);
  uint32_t mant  = static_cast<uint32_t>(divisor);
  uint32_t frac  = static_cast<uint32_t>(std::round((divisor - mant) * 16.0));
  USART2::BRR::DIV_Mantissa::Set(mant);
  USART2::BRR::DIV_Fraction::Set(frac);
  
  USART2::CR1::UE::Enable::Set();
  USART2::CR1::TE::Enable::Set();
  NVIC::ISER1::Write(1U << 6U);
}

void Usart::SendMessage(const char* message)
{
  if (mBufferLength != 0)
  {
    return;
  }

  std::size_t len = std::strlen(message);
  if (len >= mBufferCapacity)
  {
    len = mBufferCapacity - 1;
  }
  std::memcpy(mBuffer, message, len);
  mBuffer[len] = '\0';

  mBufferLength = len;
  mIndex = 0;

  if (USART2::SR::TXE::DataRegisterEmpty::IsSet())
  {
    USART2::DR::Write(static_cast<uint8_t>(mBuffer[mIndex++]));
  }
  
  USART2::CR1::TXEIE::InterruptWhenTXE::Set();
}

bool Usart::IsBusy()
{
  return mBufferLength != 0;
}

void Usart::HandleInterrupt()
{
  if (!USART2::SR::TXE::DataRegisterEmpty::IsSet())
  {
    return;
  }

  if (mIndex < mBufferLength)
  {
    USART2::DR::Write(static_cast<uint8_t>(mBuffer[mIndex++]));
  }
  else
  {
    USART2::CR1::TXEIE::InterruptInhibited::Set();
    mBufferLength = 0;
    mIndex = 0;
  }
}
----

Чтобы прерывания через USART корректно обрабатывались микроконтроллером, необходимо добавить обработчик прерываний в файл *startupF411RE.cpp*.

.startupF411RE.cpp
[source, cpp]
----
#pragma language = extended
#pragma segment = "CSTACK"
#include "AHardware/IrqController/irqcontroller.hpp"
#include "Rtos/wrapper/rtos.hpp"
#include "Usart.hpp" // for Usart

extern "C" void __iar_program_start( void );
extern "C" void xPortPendSVHandler(void);

extern "C" void UsartInterruptHandler(void)
{
  Usart::Instance().HandleInterrupt();
}

class DummyModule
{
  public:
    static void handler();
};

using tIntFunct = void(*)();
//cstat !MISRAC++2008-9-5-1
using tIntVectItem = union {tIntFunct __fun; void * __ptr;};

// The vector table is normally located at address 0.
// When debugging in RAM, it can be located in RAM, aligned to at least 2^6.
// If you need to define interrupt service routines,
// make a copy of this file and include it in your project.
// The name "__vector_table" has special meaning for C-SPY:
// it is where the SP start value is found, and the NVIC vector
// table register (VTOR) is initialized to this address if != 0.

#pragma location = ".intvec"
//cstat !MISRAC++2008-0-1-4_b !MISRAC++2008-9-5-1
extern "C" const tIntVectItem __vector_table[] =
{
  { .__ptr = __sfe( "CSTACK" ) },
  __iar_program_start,

  DummyModule::handler,
  DummyModule::handler,
  DummyModule::handler,
  DummyModule::handler,
  DummyModule::handler,
  0,
  0,
  0,
  0,
  OsWrapper::Rtos::HandleSvcInterrupt,
  DummyModule::handler,
  0,
  xPortPendSVHandler,
  OsWrapper::Rtos::HandleSysTickInterrupt,
  //External Interrupts
  DummyModule::handler,         //Window Watchdog
  DummyModule::handler,         //PVD through EXTI Line detect/EXTI16
  DummyModule::handler,         //Tamper and Time Stamp/EXTI21 
  DummyModule::handler,         //RTC Wakeup/EXTI22 
  DummyModule::handler,         //FLASH
  DummyModule::handler,         //RCC
  DummyModule::handler,         //EXTI Line 0
  DummyModule::handler,         //EXTI Line 1
  DummyModule::handler,         //EXTI Line 2
  DummyModule::handler,         //EXTI Line 3
  DummyModule::handler,         //EXTI Line 4
  DummyModule::handler,         //DMA1 Stream 0
  DummyModule::handler,         //DMA1 Stream 1
  DummyModule::handler,         //DMA1 Stream 2
  DummyModule::handler,         //DMA1 Stream 3
  DummyModule::handler,         //DMA1 Stream 4
  DummyModule::handler,         //DMA1 Stream 5
  DummyModule::handler,         //DMA1 Stream 6
  DummyModule::handler,         //ADC1
  0,                            //USB High Priority
  0,                            //USB Low  Priority
  0,                            //DAC
  0,                            //COMP through EXTI Line
  DummyModule::handler,         //EXTI Line 9..5
  DummyModule::handler,         //TIM9/TIM1 Break interrupt 
  DummyModule::handler,         //TIM10/TIM1 Update interrupt
  DummyModule::handler,         //TIM11/TIM1 Trigger/Commutation interrupts
  DummyModule::handler,		//TIM1 Capture Compare interrupt
  DummyModule::handler,         //TIM2  	
  DummyModule::handler,         //TIM3
  DummyModule::handler,         //TIM4
  DummyModule::handler,         //I2C1 Event
  DummyModule::handler,         //I2C1 Error
  DummyModule::handler,         //I2C2 Event
  DummyModule::handler,         //I2C2 Error
  DummyModule::handler,         //SPI1
  DummyModule::handler,         //SPI2
  DummyModule::handler,         //USART1
  UsartInterruptHandler,         //USART2
  0,
  IrqController::HandleIrqExtiLine15_10,         //EXTI Line 15..10
  DummyModule::handler,         //EXTI Line 17 interrupt / RTC Alarms (A and B) through EXTI line interrupt
  DummyModule::handler,         //EXTI Line 18 interrupt / USB On-The-Go  FS Wakeup through EXTI line interrupt
  0,				//TIM6
  0,				//TIM7  f0
  0,
  0,
  DummyModule::handler,         //DMA1 Stream 7 global interrupt fc
  0,
  DummyModule::handler,	        //SDIO global interrupt
  DummyModule::handler,	        //TIM5 global interrupt
  DummyModule::handler,	        //SPI3 global interrupt
  0,			        // 110
  0,
  0,
  0,
  DummyModule::handler,		//DMA2 Stream0 global interrupt 120
  DummyModule::handler,		//DMA2 Stream1 global interrupt
  DummyModule::handler,		//DMA2 Stream2 global interrupt
  DummyModule::handler,		//DMA2 Stream3 global interrupt
  DummyModule::handler,		//DMA2 Stream4 global interrupt 130
  0,
  0,
  0,
  0,
  0,
  0,
  DummyModule::handler,		//USB On The Go FS global interrupt, 14C
  DummyModule::handler,		//DMA2 Stream5 global interrupt
  DummyModule::handler,		//DMA2 Stream6 global interrupt
  DummyModule::handler,		//DMA2 Stream7 global interrupt
  DummyModule::handler,				//USART6 15C
  DummyModule::handler,         //I2C3 Event
  DummyModule::handler,         //I2C3 Error 164
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  DummyModule::handler,		//FPU 184
  0,
  0,
  DummyModule::handler,		//SPI 4 global interrupt
  DummyModule::handler		//SPI 5 global interrupt
};
void DummyModule::handler()   { for(;;) {} } ;

extern "C" void __cmain( void );
extern "C" __weak void __iar_init_core( void );
extern "C" __weak void __iar_init_vfp( void );

#pragma required=__vector_table
void __iar_program_start( void )
{
  __iar_init_core();
  __iar_init_vfp();
  __cmain();
}
----

==== Класс Formatter

Класс *Formatter* форматирует строку и приводит ее к <<output_format, заданному виду>>. Он наследуется от интерфейса *IFormatter* и не зависит от класса *Usart*.

.IFormatter.hpp
[source, cpp]
----
#ifndef IFORMATTER_HPP
#define IFORMATTER_HPP

#include <cstdint> // for std::uint8_t

class IFormatter
{
public:
  virtual char* FormatString(const float value, const uint8_t precision, const char* unit, bool isFilteredValue) = 0;
};

#endif
----

.Formatter.hpp
[source, hpp]
----
#ifndef FORMATTER_HPP
#define FORMATTER_HPP

#include "IFormatter.hpp" // for IFormatter

class Formatter : public IFormatter
{
public:
  Formatter();
  char* FormatString(const float value, const uint8_t precision, const char* unit, bool isFilteredValue = false) override;
private:
  char mBuffer[250];
  const char* mPrefix;
};

#endif
----

.Formatter.cpp
[source, cpp]
----
#include "Formatter.hpp" // for Formatter
#include <string> // for std::snprintf

Formatter :: Formatter() : mPrefix(nullptr)
{}

char* Formatter :: FormatString(const float value, const uint8_t precision, const char* unit, bool isFilteredValue)
{
  mPrefix = isFilteredValue
    ? "Отфильтрованное напряжение: "
      : "Неотфильтрованное напряжение: ";
  
  std::snprintf(mBuffer, sizeof(mBuffer), "%s%.*f%s\r\n", mPrefix, precision, static_cast<double>(value), unit);
      
  return mBuffer;
}
----

=== Хранение данных

.Блок хранения данных
[plantuml]
----
include::design/data_storage_block.puml[]
----

Блок хранения данных состоит из класса *DataRepository*, который наследуется от интерфейсов *IDataRepositoryUpdater* и *IDataRepositoryProvider*.

==== Класс DataRepository

Класс *DataRepository* предназначен для хранения отфильтрованного и неотфильтрованного значений напряжения.

Интерфейс *IDataRepositoryUpdater* предоставляет методы для записи данных в репозиторий:

* *UpdateValue()* - записывает неотфильтрованное значение.
* *UpdateFilteredValue()* - записывает отфильтрованное значение.

Интерфейс *IDataRepositoryProvider* предоставляет методы, позволяющие получить записанные в репозитории значения:

* *GetValue()* - получает неотфильтрованное значение.
* *GetFilteredValue()* - получает отфильтрованное значение.

.IDataRepositoryUpdater
[source, cpp]
----
#ifndef IDATAREPOSITORYUPDATER_HPP
#define IDATAREPOSITORYUPDATER_HPP

class IDataRepositoryUpdater
{
public:
  virtual float UpdateValue(float value) = 0;
  virtual float UpdateFilteredValue(float filteredValue) = 0;
};

#endif // IDATAREPOSITORYUPDATER_HPP
----

.IDataRepositoryProvider
[source, cpp]
----
#ifndef IDATAREPOSITORYPROVIDER_HPP
#define IDATAREPOSITORYPROVIDER_HPP

class IDataRepositoryProvider
{
public:
  virtual float GetValue() const = 0;
  virtual float GetFilteredValue() const = 0;
};

#endif //IDATAREPOSITORYPROVIDER_HPP
----

.DataRepository.hpp
[source, cpp]
----
#ifndef DATAREPOSITORY_HPP
#define DATAREPOSITORY_HPP

#include "IDataRepositoryProvider.hpp" //for IDataRepositoryProvider
#include "IDataRepositoryUpdater.hpp" //for IDataRepositoryUpdater

class DataRepository: public IDataRepositoryProvider, public IDataRepositoryUpdater
{
public:
  DataRepository();
  float GetValue() const override;
  float GetFilteredValue() const override;
  float UpdateValue(float value) override;
  float UpdateFilteredValue(float filteredValue) override;
private:
  float mValue;
  float mFilteredValue;
};

#endif
----

.DataRepository.cpp
[source, cpp]
----
#include "DataRepository.hpp"   // for DataRepository

DataRepository :: DataRepository()
{
}

float DataRepository :: GetValue() const
{
  return mValue;
}

float DataRepository :: GetFilteredValue() const
{
  return mFilteredValue;
}

float DataRepository :: UpdateValue(float value)
{
  return mValue = value;
}

float DataRepository :: UpdateFilteredValue(float filteredValue)
{
  return mFilteredValue = filteredValue;
}
----

=== Основной файл проекта

Конфигурация всех регистров микрконтроллера, а также создание задач описывается в файле *main.cpp*. У задачи *MeasurementTask* приоритет высокий, а у задачи *UsartTask* - низкий. Кроме того, основные параметры также указываются в этом файле, а именно:

* *leds* - массив светодиодов
* *dt* - интервал времени между измерениями (100 мс);
* *rc* - постоянная времени фильтра;
* *minAdcCounts* - счеты АЦП, соответствующие минимальному напряжению;
* *maxAdcCounts* - счеты АЦП, соответствующие максимальному напряжению;
* *minVoltage* - минимальное напряжение (измерено мультиметром и составляет 0,0001 В);
* *maxVoltage* - максимальное напряжение (измерено мультиметром и составляет 3,275 В);
* *maxLedAmount* - число светодиодов на плате (4 штуки).

.main.cpp
[source, cpp]
----
#include "rtos.hpp"         // for Rtos

#include "rccregisters.hpp" // for RCC

#include "gpioaregisters.hpp"  // for GPIOA
#include "gpiocregisters.hpp"  // for GPIOC
#include "usart2registers.hpp" // for Usart2 registers

#include "AdcDmaDataProvider.hpp" // for AdcDmaDataProvider
#include "DigitalFilter.hpp" // for DigitalFilter
#include "Voltage.hpp" // for Voltage
#include "DataRepository.hpp" // for DataRepository
#include "LedController.hpp" // for LedController
#include "LedCalculator.hpp" // for LedCalculator
#include "Usart.hpp" // for Usart
#include "Formatter.hpp" // for Formatter

#include "MeasurementTask.hpp" // for MeasurementTask
#include "UsartTask.hpp" // for UsartTask

std::uint32_t SystemCoreClock = 8'000'000U;

extern "C" {
  int __low_level_init(void)
  {
    //Switch on external 8 MHz oscillator
    RCC::CR::HSEON::On::Set();
    while (RCC::CR::HSERDY::NotReady::IsSet())
    {

    }
    //Switch system clock on external oscillator
    RCC::CFGR::SW::Hse::Set();
    while (!RCC::CFGR::SWS::Hse::IsSet())
    {

    }
    RCC::CR::HSION::Off::Set();
    
    //Switch on clock on PortA and PortC
    RCC::AHB1ENRPack<
      RCC::AHB1ENR::GPIOCEN::Enable,
      RCC::AHB1ENR::GPIOAEN::Enable
        >::Set();

    RCC::APB2ENR::SYSCFGEN::Enable::Set();

    //LED1 on PortA.5, set PortA.5 as output
    GPIOA::MODER::MODER5::Output::Set();

    /* LED2 on PortC.9, LED3 on PortC.8, LED4 on PortC.5 so set PortC.5,8,9 as output */
    GPIOC::MODERPack<
      GPIOC::MODER::MODER5::Output,
      GPIOC::MODER::MODER8::Output,
      GPIOC::MODER::MODER9::Output
        >::Set();
    // Potentiometer on Port A0
    GPIOA::MODER::MODER0::Analog::Set();
    // RCC on ADC
    RCC::APB2ENR::ADC1EN::Enable::Set();
    // RCC on DMA
    RCC::AHB1ENR::DMA2EN::Enable::Set();
    // RCC on USART2
    RCC::APB1ENR::USART2EN::Enable::Set();
    return 1;
  }
}

constexpr auto dt = 0.1f;
constexpr auto rc = 1.0f;
constexpr auto minAdcCounts = 2U;
constexpr auto maxAdcCounts = 4093U;
constexpr auto minVoltage = 0.0001f;
constexpr auto maxVoltage = 3.275f;
constexpr uint8_t maxLedAmount = 4U;

AdcDmaDataProvider adc;
DigitalFilter digitalFilter(dt, rc);
Voltage<maxAdcCounts, minAdcCounts, maxVoltage, minVoltage> voltage(static_cast<IRawDataProvider&>(adc));
DataRepository dataReposiitory;
LedCalculator ledCalculator(maxLedAmount, maxVoltage);
LedController ledController;
auto& usart = Usart::Instance();
Formatter formatter;

MeasurementTask measurementTask(adc, digitalFilter, voltage, ledCalculator, ledController, dataReposiitory);
UsartTask usartTask(dataReposiitory, usart, formatter);

int main()
{
  adc.ConfigAdc();
  usart.ConfigUsart();
  using namespace OsWrapper;
  Rtos::CreateThread(measurementTask, "MeasurementTask", ThreadPriority::priorityMax);
  Rtos::CreateThread(usartTask, "UsartTask", ThreadPriority::lowest);
  Rtos::Start();
  return 0;
}
----

== Заключение

В рамках выполнения курсового проекта было разработано программное обеспечение для устройства индикации напряжения. Напряжение меняется потенциометром, установленным на плате расширения. Измерение и фильтрация напряжения производится раз в 50 мс, а отправка значений по USART осуществляется раз в 500 мс. Кроме того, в зависимости от текущего значения отфильтрованного напряжения осуществляется индикация светодиодами.

Результаты готового устройства представлены на видео:

* link:media/led_demonstration.mp4[демонстрация индикации напряжения];
* link:media/terminal_demonstration.mp4[демонстрация отправки сообщений в терминал].