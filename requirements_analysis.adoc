:description: Курсовой проект
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:imagesdir: media
:important-caption: ВАЖНО!
:note-caption: ПРИМЕЧАНИЕ
:stem:

= Курсовой проект
:sectnums: |,all|

== Требования к ПО

* Для разработки должна использоваться отладочная плата https://www.waveshare.com/product/arduino-2/boards-kits/nucleo/xnucleo-f411re.htm[XNUCLEO-F411RE]
* Софт должен измерять напряжения с переменного резистора, уставленного на плате расширения
** Для измерения напряжения должен использоваться встроенный АЦП
** [[period]] Период измерения должен быть 50 ms
** [[DMA]] Для получения кода измерения должен использоваться механизм DMA
** Для изменения напряжения должна использоваться плата https://www.waveshare.com/product/arduino-2/shields/others/accessory-shield.htm[Accessories Shield] или https://www.waveshare.com/product/arduino-2/shields/others/analog-test-shield.htm[Analog Test Shield]
** Точность измерения напряжения должна быть не менее 0,01 вольта
** [[filter]] К измеренному напряжению должен быть применен цифровой фильтр вида: +

[%center]
[latexmath]
++++
\tau = \begin{cases} 
1 - e^{-\frac{dt}{RC}}, & RC > 0~\text{сек} \\
1, & RC \leq 0~\text{сек}
\end{cases} \\
FilteredValue = OldFiltered + (Value - OldValue) \cdot \tau
++++

где dt -  100 мс; +
Value – текущее нефильтрованное измеренное значение напряжения; +
oldValue -  предыдущее фильтрованное значение.

* [[leds]] Индикация значения измеренного напряжения должна осуществляться через включение/выключение светодиодов
** При максимальном напряжении софт должен зажигать 4 светодиода, при минимальном все светодиоды должны погаснуть.
** Промежуточные значения напряжения должны индицироваться следующим образом.
*** При 0-25% от максимального напряжения зажигается только 1 светодиод
*** При 25-50% от максимального напряжения зажигается только 2 светодиода
*** При 50-75% от максимального напряжения зажигается только 3 светодиода
*** При 75-100% от максимального напряжения зажигается все 4 светодиода

* [[UART]] Передача значений по беспроводному интерфейсу должна осуществляться через модуль https://elecfreaks.com/estore/download/EF03073-Bluetooth_Bee_(HC-05_and_HC-06)User_Guide.pdf[BlueTooth Bee HC-06]
 или https://www.waveshare.com/product/arduino-2/shields/others/io-expansion-shield.htm[I/O Expansion Shield]
** Общение с платой расширения должно осуществляться через USART2
** [[output_format]] формат вывод: +
   "Напряжение: " X.XXX [Units] +
   "Неотфильтрованное апряжение: " X.XXX [Units]
* Архитектура должна быть представлена в виде UML диаграмм в пакете Plant UML
* Приложение должно быть написано на языке С++ с использование компилятора ARM 8.40.2
* [[RTOS]] При разработке должна использоваться Операционная Система Реального Времени FreeRTOS и https://github.com/lamer0k/RtosWrapper[С++ обертка над ней]

== Анализ требований к ПО

=== Отладочная плата XNUCLEO-F411RE и плата расширения Accessory Shield

Отладочная плаата XNUCLEO-F411RE - это улучшенная версия отладочной платы STM32 Nucleo, созданная компанией Waveshare. Основана XNUCLEO-F411RE на микроконтроллере STM32F411RET6 с ядром ARM Cortex-4 и предназначена для создания проектов и прототипирования. 

.Отладочная плата XNUCLEO-F411RE
image::XNUCLEO-F411RE.jpg[]

Основные особенности платы XNUCLEO-F411RE:

* совместимость с Arduino;
* подключение по USB;
* наличие светодиодов и пользовательской кнопки.

В ходе выполнения курсового проекта используется плата расширения Accessory Shield.

.Плата расширения Accessory Shield
image::accessory_shield.jpg[]

Accessory Shield - это плата расширения совместимая с популярными платформами для разработки электронных приложений, такими как Arduino UNO, Arduino Leonardo, NUCLEO, XNUCLEO и совместимыми. На плате установлены самые популярные дочерние модули, подходящие для реализации большинства задач.

Особенности платы расширения:

* разъем для подключения плат Arduino;
* разъем XBee для подключения беспроводных модулей;
* OLED дисплей 0,96 дюймов с разрешением 128x64 пикселей;
* RGB-светодиод;
* зуммер;
* потенциометр 10 кОм;
* 3-осевой цифровой акселерометр ADXL345;
* температурный датчик LM75BDP,
* джойстик 5-ти позиционный,
* индикатор состояния XBee,
* индикатор питания,
* кнопка сброса модулей XBee и Arduino,
* часы реального времени (RTC),
* держатель батареи CR1220 для RTC,
* драйвер RGB светодиода,
* джампер выбора режима Отладка/Связь.

=== Софт должен измерять напряжение с переменного резистора, установленного на плате расширения

Переменный резистор, установленный на плате расширения, согласно спецификации Waveshare, подключен к аналоговому входу микроконтроллера, пин *PA0*.

.Распиновка XNUCLEO-F411RE
image::xnucleo_spec.jpg[]

В плате расширения используется линейный потенциометр с тремя выводами:

* один крайний вывод подключен в питанию (стандартное напряжение питания, необходимо определить точно с помощью прецизионного мультиметра);
* другой крайний вывод подключен к земле;
* центральный вывод выведен на аналоговый вход микроконтроллера (пин PA0).

Таким образом, при вращении ручки потенциометра напряжение на центральном выводе изменяется от 0 В до 3,3 В.

Поскольку напряжение - аналоговый сигнал, его нужно измерять с помощью аналого-цифрового преобразователя (АЦП).

=== Для измерения напряжения должен использоваться встроенный АЦП с использованием DMA

Микроконтроллер STM32F411RET6 оснащен 12-битным АЦП, поддерживающим 19 каналов и позволяющим имзерять сигналы из 16 внешних источников, 2 внутренних источников, а также канал VBAT (измерение напряжения на линии питания резервной батареи).

Аналого-цифровое преобразование каналов может осуществляться в следующих режимах:

* Single Mode (однократное преобразование) - для выбранного канала преобразование выполняется один раз и останавливается после завершения.
* Continuous Mode (непрерывное преобразование) - автоматическое повторение преобразования выбранного канала без необходимости повторного запуска.
* Scan Mode (режим сканирования) - АЦП выполняет преобразование для группы каналов, заданных в последовательности, по одному за раз. Этот режим не является самостоятельным, а комбинируется с Single или Continuous.
* Discontinuous Mode (Прерывистый режим) - улучшенный режим  сканирования. Разбивает последовательность каналов на подгруппы. АЦП выполняет преобразование заданного числа каналов за один цикл, затем останавливается до следующего триггера.

Поскольку, <<DMA, согласно требованиям к ПО>>, требуется использовать механизм DMA совместно с АЦП, следует использовать режим непрерывного преобразования. АЦП будет передавать считанные значения с помощью DMA автоматически по выбранному адресу, без использования ядра процессора.

Для того, чтобы настроить АЦП в режиме непрерывного преобразования  и использовать его вместе с DMA, нужно:

. подать тактирование на порт, который будет использоваться для считывания данных с АЦП;
. настроить порт, подключенный к нужному каналу АЦП, на аналоговый вход;
. подать тактирование на АЦП;
. настроить разрешение АЦП;
. настроить режим преобразования (регистр ADC_CR2);
. установить количество каналов для опроса (поле L регистра ADC_SQR1);
. выбрать нужный канал для измерения;
. настроить канал АЦП на необходимую частоту преобразования;
. подать тактирование на модуль DMA;
. выбрать поток и канал DMA, соответствующие используемому АЦП;
. указать адрес источника DMA (регистр данных АЦП, ADC_DR);
. указать адрес назначения DMA (буфер в памяти для хранения данных);
. настроить размер данных и направление передачи;
. установить количество данных (размер буфера);
. включить режим циклической передачи DMA (для непрерывного измерения);
. включить запрос DMA в АЦП (бит DMA в регистре ADC_CR2);
. включить АЦП;
. начать преобразование АЦП (бит ADSTART в регистре ADC_CR2).

В <<table_ADC, данной таблице>> показаны настройки регистров, необходимых для включения АЦП в режиме непрерывного преобразования.

<<DMA, Согласно требованиям к ПО>>, для получения кода измерения должен использоваться механизм DMA. DMA - это режим обмена данными между периферией и основной памятью, в котором центральный процессор не участвует. Для работы с DMA в микроконтроллер встроены специальные контроллеры DMA.

На микроконтроллере STM32F411RET6 имеется 2 контроллера DMA, каждый из которых имеет 8 каналов, каждый канал имеет 8 потоков, которые подключаются к конкретному периферийному устройству. Если установлен бит DMA регистра ADC_CR2, то по окончании преобразования АЦП генерирует запрос DMA. Контроллер DMA получит этот запрос по внутренней линии связи между периферией и DMA. Затем контроллер DMA считывает данные с АЦП (записанные в регистр ADC_DR) и записывает их в указанный адрес памяти.

В спецификации к микроконтроллеру имеется таблица запросов DMA.

.Таблица запросов DMA
image::DMA_Requests_Tables.png[]

Согласно этой таблице, для того, чтобы генерировать запросы от АЦП, следует использовать контроллер DMA2, канал 0, потоки 0 или 4. В данной работе используется поток 0.

В <<table_DMA, данной таблице>> показана конфигурация регистров DMA для данного проекта.

Алгоритм настройки потока DMA представлен в пункте 9.3.17 в https://www.st.com/resource/en/reference_manual/rm0383-stm32f411xce-advanced-armbased-32bit-mcus-stmicroelectronics.pdf[Reference Manual] к STM32F411RET6.

image::DMA_algorythm1.png[]
.Алгоритм настройки потока DMA
image::DMA_algorythm2.png[]

=== Индикация измеренного напряжения светодиодами

<<leds, Согласно требования к ПО>>, индикация измеренного напряжения должна производиться так:

[cols="^,^"]
.Индикация измеренного напряжения светодиодами в зависимостит от положения ручки переменного резистора
|===
| % от максимального напряжения | Количество светодиодов
| 0-25 | 1
| 25-50 | 2
| 50-75 | 3
| 75-100 | 4
|===

Для расчета количества светодиодов предлагается использовать следующую формулу:

[%center]
[latexmath]
++++
LED_{curr} = \lceil\frac{V_{ADC} \cdot LED_{max}}{V_{ref}}\rceil,
++++

где latexmath:[V_{ADC}] - измеренное АЦП напряжение;
latexmath:[LED_{max} = 4] - количество светодиодов на плате;
latexmath:[V_{ref}] - опорное напряжение.

=== Периодичность измерений 50 мс с использованием операционной системы реального времени FreeRTOS

Поскольку, <<period, согласно требованиям к ПО>>, измерения необходимо производить с заданной периодичностью (50 мс), целесообразно использовать операционную систему реального времени.

Операционная система реального времени (ОСРВ) — это ОС, которая предназначена для обработки данных и выполнения задач в строго заданные временные рамки. Она гарантирует, что критически важные процессы завершатся вовремя, минимизируя задержки.

<<RTOS, Согласно требованиям к ПО>>, должна использоваться операционная система реального времени FreeRTOS и обертка над ней. *FreeRTOS* — это компактная операционная система реального времени (ОСРВ) с открытым исходным кодом, предназначенная для встраиваемых систем и микроконтроллеров. Она предоставляет базовые функции для управления задачами, планирования, синхронизации (семафоры, мьютексы, очереди) и работы с ограниченными ресурсами. Под *оберткой* понимается программный слой или библиотека, которая упрощает взаимодействие с FreeRTOS, скрывая её низкоуровневые детали и упрощая разработку.

Так как АЦП и DMA после настройки работают независимо от ядра микроконтроллера, создавать задачу для организации передачи данных между ними не нужно.

В данной таблице представлены задачи, которые выполняются операционной системой реального времени.

[cols="^,^,^,^"]
.Задачи, выполняемые операционной системой реального времени
|===
| Задача | Описание | Периодичность | Приоритет
| [[task1]] Расчет считанного значения напряжения, переданного по DMA | Читает счеты АЦП из ячеек памяти, куда пишет DMA; переводит счеты АЦП в напряжение; выполняет фильтрацию; управляет светодиодами | 50 мс | Высокий
| Передача данных по UART | Считывает значения, полученные из первой задачи и отправляет их по UART в заданном формате | 500 мс | Низкий
|===

Т.к. UART посылает данные реже, чем происходят измерения, можно использовать один и тот же объект для двух задач, блокируя его примитивом синхронизации. Однако, поскольку передаются всего лишь 2 числа в формате *float*, а этот формат состоит из 4 байт, передающихся атомарно, необходимости использовать блокировку нет. Поэтому, в данной работе решено использовать эти числа без блокировки.

=== Обеспечение точности не менее 0,01 В

Для того, чтобы обеспечить измерение напряжения с требуемой точностью, необходимо обеспечить корректную работу АЦП в непрерывном режиме с передачей данных через DMA.

Точность измерения напряжения определяется следующими факторами:

. Разрешение АЦП: Количество бит влияет на шаг квантования (latexmath:[\Delta V])
. Опорное напряжение: Задает диапазон измерений
. Частота АЦП: Влияет на длительность выборки  преобразования

==== Выбор параметров тактирования

Поскольку в требованиях к ПО не сказано, каким должно быть потребление ресурсов, было решено использовать внешний кварцевый генератор с частотой тактирования 8 МГц. Его будет достаточно для выполнения всех задач.

==== Выбор разрешения АЦП

В STM32F411RET6 АЦП поддерживает разрешения 6, 8, 10 и 12 бит. Формула расчета шага квантования:

[%center]
[latexmath]
++++
\Delta V = \frac{V_{ref}}{2^n},
++++

где latexmath:[V_{ref} = 3,3 V] - опорное напряжение;
   latexmath:[n] - разрядность АЦП.

Рассмотрим варианты квантования при различных разрешениях.

При latexmath:[n] = 8 бит:

[%center]
[latexmath]
++++
\Delta V = \frac{3,3}{2^8} = \frac{3,3}{256} = 12,891 mV
++++

При latexmath:[n] = 10 бит:

[%center]
[latexmath]
++++
\Delta V = \frac{3,3}{2^{10}} = \frac{3,3}{1024} = 3,223 mV
++++

При latexmath:[n] = 12 бит:

[%center]
[latexmath]
++++
\Delta V = \frac{3,3}{2^{12}} = \frac{3,3}{4096} = 0,806 mV
++++

Как можно заметить, 8 бит разрешения не достаточно для обеспечения требуемой точности. 10 бит хватает, но для обеспечения большей устойчивости к шумам следует выбрать разрешение *12 бит*, т.е. установить в регистре ADC_CR1 в поле RES биты 00.

==== Выбор времени преобразования АЦП

Время преобразования необходимо выбрать таким, чтобы оно было меньше заданного периода измерения, т.е. 50 мс.

Чем больше время преобразования, тем точнее преобразованное значение. Руководствуясь этим суждением, следует выбрать время преобразования, максимально близкое к 50 мс.

АЦП тактируется от шины APB2, частота которой в контексте данной задачи равна 8 МГц. В регистре ADC_CCR в поле ADCPRE настраивается значение предделителся частоты. Его минимальное значение составляет 2 (биты 00). Тогда, АЦП тактируется от частоты latexmath:[\frac{8 MHz}{2} = 4 MHz].

Время одного такта АЦП равно:

[%center]
[latexmath]
++++
T_{cycle} = \frac{1}{4 \cdot 10^6} = 0,25 μs.
++++

Время выборки АЦП определяется по формуле:

[%center]
[latexmath]
++++
T_{sample} = N_{sample} \cdot T_{cycle},
++++

где latexmath:[N_{sample}] - количество циклов выборки (настраивается в регистре ADC_SMPR2, поле SMP0).

Время преобразования АЦП определяется по формуле:

[%center]
[latexmath]
++++
T_{conversion} = (N_{sample} + N_{resolution}) \cdot T_{cycle},
++++
где latexmath:[N_{sample}] - количество циклов выборки (настраивается в регистре ADC_SMPR2, поле SMP0); latexmath:[N_{resolution}] - разрешение АЦП (было выбрано 12 бит).

Ниже рассчитаны различные значения времени преобразования в зависимости от количества циклов выборки.

[cols="^,^"]
.Расчет времени преобразования
|===
| latexmath:[N_{sample}] | latexmath:[T_{conversion}], мкс
| 3 | 3,75
| 15 | 6,75
| 28 | 10
| 56 | 17
| 84 | 24
| 112 | 31
| 144 | 39
| 480 | 123
|===

Выберем самое большое количество циклов, т.е. 480 (биты 111 в поле SMP0 регистра ADC_SMPR2).

==== Формула расчета напряжения

Для того, чтобы соблюсти требуемую точность, необходимо точно знать опорное напряжение latexmath:[V_{ref}]. Хотя номинально на плате напряжение питания равно 3,3 В, на самом деле оно не стабильно и может отклоняться от этого значения. Чтобы измежать этой нестабильности, необходимо осуществить калибровку.

Существует 2 пути калибровки:

* Измерять latexmath:[V_{ref}] с помощью специального канала АЦП и калиброваться от него.
* Измерить прецизионным мультиметром несколько экспериментальных точек, относительно которых будет осуществляться калибровка.

В данной работе калибровка осуществляется с помощью мультиметра.

Чтобы составить математическую модель, по которой будет осуществляться калибровка, необходимо также учесть влияние нелинейности АЦП на измерение напряжения. Согласно спецификации к STM32F411RET6, ошибки нелинейности АЦП зависят от частоты, при которой АЦП работает и становятся больше рпи ее увеличении:

.Ошибки нелинейности АЦП
image::ADC_Lin.png[]

Максимальная интегральная ошибка (т.е. отклонение максимальное отклонение реальной передаточной характеристики АЦП от идеальной прямой) составляет 6 LSB (минимально значащих битов). В вольтах:

[%center]
[latexmath]
++++
Error_{EL} = \Delta V \cdot 6 = 6 \cdot 0,806 = 4,836 mV.
++++

Максимальная дифференциальная ошибка (т.е. отклонение шага квантования от идеального) составляет 3 LSB. В вольтах:

[%center]
[latexmath]
++++
Error_{ED} = \Delta V \cdot 3 = 3 \cdot 0,806 = 2,418 mV.
++++

Как можно заметить, обе ошибки не превышают требуемой точности 10 мВ, т.е. можно считать, что нелинейность АЦП несущественна, и ей можно пренебречь. Тогда для калибровки можно использовать математическую модель, представляющую собой линейную функцию. Для составления такой модели достаточно измерить мультиметром всего 2 точки. В данной работе измеряются минимальное напряжение и максимальное напряжение. Формула преобразования счетов АЦП в напряжение с калибровкой показана ниже:

[%center]
[latexmath]
++++
V_{ADC} = Gain \cdot ADC_{curr} + Offset,
++++

где latexmath:[Gain] - коэффициент усиления; +
latexmath:[Offset] - смещение; +
latexmath:[ADC_{curr}] - текущие счеты АЦП.

Коэффициент усиления определяется по формуле:

[%center]
[latexmath]
++++
Gain = \frac{ADC_{max} - ADC_{min}}{V_{max} - V_{min}},
++++
где latexmath:[ADC_{max}] - счеты АЦП, соответствующие максимальному напряжению; +
latexmath:[ADC_{min}] - счеты АЦП, соответствующие минимальному напряжению; +
latexmath:[V_{max}] - максимальное напряжение; +
latexmath:[V_{min}] - минимальное напряжение.

Смещение определяется по формуле:

[%center]
[latexmath]
++++
Offset = V_{max} - \frac{ADC_{max} - ADC_{min}}{V_{max} - V_{min}} \cdot ADC_{max}.
++++

Счеты АЦП должны преобразовываться в напряжение по следующей формуле (для 12-битного АЦП):

[%center]
[latexmath]
++++
V_{ADC} = \frac{ADC_{counts} \cdot V_{ref}}{4096},
++++

где latexmath:[ADC_{counts}] - текущие счеты АЦП; +
latexmath:[V_{ref} = 3,3 V] - опорное напряжение.

=== Цифровой фильтр

Согласно требованиям к ПО, к измеренному напряжению должен быть применен <<filter, цифровой фильтр>>.

Формула фильтра:

[%center]
[latexmath]
++++
\tau = \begin{cases} 
1 - e^{-\frac{dt}{RC}}, & RC > 0~\text{сек} \\
1, & RC \leq 0~\text{сек}
\end{cases} \\
FilteredValue = OldFiltered + (Value - OldValue) \cdot \tau
++++

где dt -  100 мс; +
Value – текущее нефильтрованное измеренное значение напряжения; +
oldValue -  предыдущее фильтрованное значение.

Данный фильтр представляет собой экспоненциальный сглаживающий фильтр, имитирующий поведение аналогового RC-фильтра. Он часто используется для того, чтобы подавлять шумы в измерениях напряжения и других сигналов. 

Данный фильтр применяется в <<task1, высокоприоритетной задаче>> операционной системы реального времени.

Поскольку dt -  100 мс, фильтроваться будет каждое второе снятое с АЦП значение напряжения.

=== Использование USART для передачи измеренных значений

<<UART, Согласно требованиям к ПО>>, передача измеренного напряжения должна передаваться по Bluetooth в заданном формате: *"Напряжение: " X.XXX [Units]*. Однако, поскольку информация на Bluetooth модуль поступает через UART, было решено использовать обычный UART для передачи данных на компьютер. Передаваться будут отфильтрованное значение напряжения и неотфильтрованное значение напряжения.

Передача должна осуществляться по прерыванию.

Читаться данные будут с помощью программы https://micro-pi.ru/terminal-1-9b-работаем-com-портом/[Terminal 1.9]. Формат байта UART в рамках курсового проекта можно выбрать стандартным, поскольку никаких дополнительных условий в требованиях к ПО не упоминалось:

[NOTE]
*1 стартовый бит + 8 бит данных + 1 стоповый бит, без проверки четности, режим дискретизации 1/16*

Микроконтроллер STM32F411RET6 поддерживает несколько UART-модулей. в курсовом проекте решено использовать модуль UART2, поскольку на плате XNUCLEO-F411RE он аппаратно подключен к чипу CP2102, позволяющему передавать данные UART через USB на компьютер. В данном случае для UART используются пины *PA2 (RX)* и *PA3 (TX)*.

Также необходимо правильно выбрать скорость передачи данных. Она должна быть достаточной для того, чтобы успевать передавать данные, а также не должна иметь большую ошибку (между реальной скоростью и ожидаемой).

Существует несколько стандартных скоростей передачи данных: 9600 бод, 19200 бод, 38400 бод, 57600 бод, 115200 бод. Поскольку было решено передавать данные по UART раз в 100 мс, то большая скорость передачи данных не требуется.

Рассчитаем время передачи одной строки <<output_format, заданного формата>> (19 символов) по формуле:

[%center]
[latexmath]
++++
t_{transmit} = \frac{19 \cdot 10}{9600} = 19,79 ms.
++++

Как можно заметить, скорости 9600 бод вполне достаточно для того, чтобы передавать требуемую строку раз в 100 мс.

Скорость передачи данных в UART определяется значением, записанным в регистр *USART_BRR*. Это значение рассчитывается по следующей формуле:

[%center]
[latexmath]
++++
USARTDIV = \frac{f_{CLK}}{BaudRate \cdot 8 \cdot (2 - OVER8)},
++++

где latexmath:[f_{CLK}] - системная частота; +
latexmath:[BaudRate] - желаемая скорость передачи данных, бод; +
latexmath:[OVER8] - значение, записанное в поле OVER8 регистра USART_CR1 (режим дискретизации).

Чем больше скорость - тем меньше делитель *USARTDIV* и больше ошибка от округления значения, записываемого в регистр *USART_BRR*.

Рассчитаем значение, которое необходимо записать в регистр *USART_BRR*.

[%center]
[latexmath]
++++
USARTDIV = \frac{8000000}{16 \cdot 9600} = 52,08333.
++++

Целая часть - 52, дробная часть - 0,08333.

В поле *DIV_Mantissa* регистра *USART_BRR* записывается 52 (0x340), в поле *DIV_Fraction* записывается округленное до ближайшего целого значение дробной части, т.е. 1 (0x001). Итого в регистр *USART_BRR* требуется записать значение *0x341*.

Рассчитаем ошибку для этого значения. При этом записанный в регистр делитель равен:
latexmath:[USARTDIV = \frac{52 + 1}{16} = 52,0625]:

[%center]
[latexmath]
++++
Error = \left|\frac{V_{r} - V_{d}}{V_{d}}\right| \cdot 100 \%
= \left|\frac{(\frac{f_{CLK}}{16 \cdot 52,0625}) - 9600}{9600}\right| \cdot 100 \%
= \frac{9603,84 - 9600}{9600} \cdot 100 \%
= 0,04 \%.
++++

Таким образом, реально записанная в регистр *USART_BRR* скорость составляет 9603,84 бод, с ошибкой 0,04%.

=== Таблицы регистров для настройки

[[table_RCC]]
.Настройки регистров тактирования
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.3+| RCC_CR | HSEON (16) | 1 | Включить тактирования от внешнего кварцевого генератора (8 МГц)
| HSERDY (17) | Зависит от готовности | Устанавливается в 1, когда генератор стабилен и готов к работе
| HSION (0) | 0 | Отключить внутренний генератор (16 МГц) после того, как HSE включится
| RCC_CFGR | SW (1 : 0) | 01 | Выбрать HSE в качестве системной частоты
.2+| RCC_AHB1ENR | GPIOAEN (0) | 1 | Подать тактирование на порт GPIOA
| DMA2EN (22) | 1 | Подать тактирование на контроллер DMA2
| RCC_APB1ENR | USART2EN (17) | 1 | Подать тактирование на USART2
| RCC_APB2ENR | ADC1EN (8) | 1 | Подать тактирование на АЦП
|===

[[table_GPIO]]
.Настройки регистров GPIO
|===
.3+| GPIOA_MODER | MODER0 (1 : 0) | 11 | Установить пин PA0 в режим аналогового входа (для АЦП)
| MODER2 (5 : 4) | 10 | Установить пин PA2 в режим альтернативной функции (для UART TX)
| MODER3 (7 : 6) | 10 | Установить пин PA2 в режим альтернативной функции (для UART RX)
|===

[[table_ADC]]
.Настройки регистров для АЦП в режиме непрерывного преобразования
|===
| Регистр | Поле (номера битов) | Значение | Назначение
| ADC_CR1 | RES (25 : 24) | 00 | Установить разрядность АЦП (12 бит)
.3+| ADC_CR2 | EOCS (10) | 1 | Установить тип окончания преобразования: Бит Окончания преобразования EOC устанавливается после окончания преобразования для каждого канала
| CONT (1) | 1 | Установить режим непрерывного преобразования
| DMA (8) | 1 | Включить режим DMA
| ADC_SQR1 | L (3 : 0) | 0000 | Установить количество преобразований равным 1
| ADC_SQR3 | SQ1 (4 : 0) | 0000 | Выбрать канал 0 для измерения
| ADC_SMPR2 | SMP0 (2: 0) | 111 | Установить время преобразования на 480 циклов
.2+| ADC_CR2 | ADON (0) | 1 | Запуск АЦП
| SWSTART (30) | 1 | Начать преобразование
| ADC_DR | DATA (15 : 0) | Переменное | Используется для считывания преобразованных данных
|===

[[table_DMA]]
.Регистры для настройки DMA
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.8+| DMA_S0CR | CHSEL (27 : 25) | 000 | Выбор канала 0
| DIR (7 : 6) | 00 | Направление передачи данных: от периферии к памяти
| CIRC (8) | 1 | Циклический режим включен (т.к. непрерывное преобразование)
| MINC (10) | 0 | Отключить инкремент адреса памяти (для записи одного значения)
| PINC (9) | 0 | Отключить инкремент адреса периферии (т.к. адрес АЦП фиксирован)
| PSIZE (12 : 11) | 10 | Установить размер данных периферии 32 бит (поскольку регистр данных АЦП ADC_DR имеет размер 32 бита)
| MSIZE (14 : 13) | 10 | Установить размер данных памяти 32 бита
| EN (0) | 1 или 0 | Перед настройкой DMA бит установить в 0, после настройки запустить поток и установить бит в 1
| DMA_S0PAR | PAR (31 : 0) | Адрес регистра ADC_DR | Хранит адрес АЦП
| DMA_S0MA0R | MDA (31 : 0) | Адрес памяти, куда данные будут записываться | Хранит адрес памяти, куда сохраняется результат измерений
| DMA_S0NDTR | NDT (15 : 0) | Количество данных для передачи | Хранит количество передаваемых данных
| DMA_LIFCR | CTCIF0 (5) | 1 или 0 | Сбросить флаг завершения передачи DMA
| DMA_LISR | TCIF0 (5) | 1 или 0 | Ожидание завершения передачи DMA
|===

[[table_USART]]
.Регистры для настройки UART
|===
| Регистр | Поле (номера битов) | Значение | Назначение
.5+| USART_CR1 | UE (13) | 1 | Включить UART
| TE (3) | 1 | Разрешить передачу
| M (12) | 0 | Установить формат передаваемого байта: 1 стартовый бит + 8 бит данных
| PCE (10) | 0 | Отключить четность
| OVER8 (15) | 0 | Установить дискретизацию 1/16
| USART_CR2 | STOP (13 : 12) | 00 | 1 стоп-бит
| USART_BRR | Все | (52 << 4) \| 1 | Скорость передачи 9600 бод
| USART_SR | TXE (7) | Переменное | Бит устанавливается, когда буфер передачи пуст. Срабатывает прерывание
| NVIC_ISER1 | 38 (номер в таблице векторов прерываний) | 1 | Разрешить прерывания для UART 
|===